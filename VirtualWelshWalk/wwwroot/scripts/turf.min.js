//(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.turf = f() } })(function () {
//    var define, module, exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
//        1: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function along(e, r, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var n; if ("Feature" === e.type) n = e.geometry.coordinates; else { if ("LineString" !== e.type) throw new Error("input must be a LineString Feature or Geometry"); n = e.coordinates } if (!helpers.isNumber(r)) throw new Error("distance must be a number"); for (var i = 0, o = 0; o < n.length && !(r >= i && o === n.length - 1); o++) { if (i >= r) { var a = r - i; if (a) { var u = bearing(n[o], n[o - 1]) - 180; return destination(n[o], a, u, t) } return helpers.point(n[o]) } i += measureDistance(n[o], n[o + 1], t) } return helpers.point(n[n.length - 1]) } var bearing = _interopDefault(require("@turf/bearing")), destination = _interopDefault(require("@turf/destination")), measureDistance = _interopDefault(require("@turf/distance")), helpers = require("@turf/helpers"); module.exports = along, module.exports.default = along;

//        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6 }], 2: [function (require, module, exports) {
//            "use strict"; function bearing(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); if (!0 === a.final) return calculateFinalBearing(e, r); var i = invariant.getCoord(e), n = invariant.getCoord(r), s = helpers.degreesToRadians(i[0]), t = helpers.degreesToRadians(n[0]), o = helpers.degreesToRadians(i[1]), l = helpers.degreesToRadians(n[1]), h = Math.sin(t - s) * Math.cos(l), d = Math.cos(o) * Math.sin(l) - Math.sin(o) * Math.cos(l) * Math.cos(t - s); return helpers.radiansToDegrees(Math.atan2(h, d)) } function calculateFinalBearing(e, r) { var a = bearing(r, e); return a = (a + 180) % 360 } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = bearing, module.exports.default = bearing;

//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 3: [function (require, module, exports) {
//            "use strict"; function clone(e) { if (!e) throw new Error("geojson is required"); switch (e.type) { case "Feature": return cloneFeature(e); case "FeatureCollection": return cloneFeatureCollection(e); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return cloneGeometry(e); default: throw new Error("unknown GeoJSON type") } } function cloneFeature(e) { var t = { type: "Feature" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "properties": case "geometry": return; default: t[o] = e[o] } }), t.properties = cloneProperties(e.properties), t.geometry = cloneGeometry(e.geometry), t } function cloneProperties(e) { var t = {}; return e ? (Object.keys(e).forEach(function (o) { var r = e[o]; "object" == typeof r ? null === r ? t[o] = null : r.length ? t[o] = r.map(function (e) { return e }) : t[o] = cloneProperties(r) : t[o] = r }), t) : t } function cloneFeatureCollection(e) { var t = { type: "FeatureCollection" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "features": return; default: t[o] = e[o] } }), t.features = e.features.map(function (e) { return cloneFeature(e) }), t } function cloneGeometry(e) { var t = { type: e.type }; return e.bbox && (t.bbox = e.bbox), "GeometryCollection" === e.type ? (t.geometries = e.geometries.map(function (e) { return cloneGeometry(e) }), t) : (t.coordinates = deepSlice(e.coordinates), t) } function deepSlice(e) { return "object" != typeof e[0] ? e.slice() : e.map(function (e) { return deepSlice(e) }) } module.exports = clone, module.exports.default = clone;

//        }, {}], 4: [function (require, module, exports) {
//            "use strict"; function destination(e, s, a, r) { if (r = r || {}, !helpers.isObject(r)) throw new Error("options is invalid"); var t = r.units, i = r.properties, n = invariant.getCoord(e), o = helpers.degreesToRadians(n[0]), h = helpers.degreesToRadians(n[1]), d = helpers.degreesToRadians(a), p = helpers.lengthToRadians(s, t), l = Math.asin(Math.sin(h) * Math.cos(p) + Math.cos(h) * Math.sin(p) * Math.cos(d)), M = o + Math.atan2(Math.sin(d) * Math.sin(p) * Math.cos(h), Math.cos(p) - Math.sin(h) * Math.sin(l)), u = helpers.radiansToDegrees(M), c = helpers.radiansToDegrees(l); return helpers.point([u, c], i) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = destination, module.exports.default = destination;
//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 5: [function (require, module, exports) {
//            "use strict"; function distance(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); var t = a.units, s = invariant.getCoord(e), i = invariant.getCoord(r), n = helpers.degreesToRadians(i[1] - s[1]), o = helpers.degreesToRadians(i[0] - s[0]), h = helpers.degreesToRadians(s[1]), d = helpers.degreesToRadians(i[1]), p = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(h) * Math.cos(d); return helpers.radiansToLength(2 * Math.atan2(Math.sqrt(p), Math.sqrt(1 - p)), t) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = distance, module.exports.default = distance;

//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 6: [function (require, module, exports) {
//            "use strict"; function feature(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox, i = t.id; if (void 0 === r) throw new Error("geometry is required"); if (e && e.constructor !== Object) throw new Error("properties must be an Object"); o && validateBBox(o), i && validateId(i); var n = { type: "Feature" }; return i && (n.id = i), o && (n.bbox = o), n.properties = e || {}, n.geometry = r, n } function geometry(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox; if (!r) throw new Error("type is required"); if (!e) throw new Error("coordinates is required"); if (!Array.isArray(e)) throw new Error("coordinates must be an Array"); o && validateBBox(o); var i; switch (r) { case "Point": i = point(e).geometry; break; case "LineString": i = lineString(e).geometry; break; case "Polygon": i = polygon(e).geometry; break; case "MultiPoint": i = multiPoint(e).geometry; break; case "MultiLineString": i = multiLineString(e).geometry; break; case "MultiPolygon": i = multiPolygon(e).geometry; break; default: throw new Error(r + " is invalid") }return o && (i.bbox = o), i } function point(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); if (r.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!isNumber(r[0]) || !isNumber(r[1])) throw new Error("coordinates must contain numbers"); return feature({ type: "Point", coordinates: r }, e, t) } function points(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return point(r, e) }), t) } function polygon(r, e, t) { if (!r) throw new Error("coordinates is required"); for (var o = 0; o < r.length; o++) { var i = r[o]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var n = 0; n < i[i.length - 1].length; n++) { if (0 === o && 0 === n && !isNumber(i[0][0]) || !isNumber(i[0][1])) throw new Error("coordinates must contain numbers"); if (i[i.length - 1][n] !== i[0][n]) throw new Error("First and last Position are not equivalent.") } } return feature({ type: "Polygon", coordinates: r }, e, t) } function polygons(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return polygon(r, e) }), t) } function lineString(r, e, t) { if (!r) throw new Error("coordinates is required"); if (r.length < 2) throw new Error("coordinates must be an array of two or more positions"); if (!isNumber(r[0][1]) || !isNumber(r[0][1])) throw new Error("coordinates must contain numbers"); return feature({ type: "LineString", coordinates: r }, e, t) } function lineStrings(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return lineString(r, e) }), t) } function featureCollection(r, e) { if (e = e || {}, !isObject(e)) throw new Error("options is invalid"); var t = e.bbox, o = e.id; if (!r) throw new Error("No features passed"); if (!Array.isArray(r)) throw new Error("features must be an Array"); t && validateBBox(t), o && validateId(o); var i = { type: "FeatureCollection" }; return o && (i.id = o), t && (i.bbox = t), i.features = r, i } function multiLineString(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiLineString", coordinates: r }, e, t) } function multiPoint(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPoint", coordinates: r }, e, t) } function multiPolygon(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPolygon", coordinates: r }, e, t) } function geometryCollection(r, e, t) { if (!r) throw new Error("geometries is required"); if (!Array.isArray(r)) throw new Error("geometries must be an Array"); return feature({ type: "GeometryCollection", geometries: r }, e, t) } function round(r, e) { if (void 0 === r || null === r || isNaN(r)) throw new Error("num is required"); if (e && !(e >= 0)) throw new Error("precision must be a positive number"); var t = Math.pow(10, e || 0); return Math.round(r * t) / t } function radiansToLength(r, e) { if (void 0 === r || null === r) throw new Error("radians is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r * t } function lengthToRadians(r, e) { if (void 0 === r || null === r) throw new Error("distance is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r / t } function lengthToDegrees(r, e) { return radiansToDegrees(lengthToRadians(r, e)) } function bearingToAzimuth(r) { if (null === r || void 0 === r) throw new Error("bearing is required"); var e = r % 360; return e < 0 && (e += 360), e } function radiansToDegrees(r) { if (null === r || void 0 === r) throw new Error("radians is required"); return r % (2 * Math.PI) * 180 / Math.PI } function degreesToRadians(r) { if (null === r || void 0 === r) throw new Error("degrees is required"); return r % 360 * Math.PI / 180 } function convertLength(r, e, t) { if (null === r || void 0 === r) throw new Error("length is required"); if (!(r >= 0)) throw new Error("length must be a positive number"); return radiansToLength(lengthToRadians(r, e), t || "kilometers") } function convertArea(r, e, t) { if (null === r || void 0 === r) throw new Error("area is required"); if (!(r >= 0)) throw new Error("area must be a positive number"); var o = areaFactors[e || "meters"]; if (!o) throw new Error("invalid original units"); var i = areaFactors[t || "kilometers"]; if (!i) throw new Error("invalid final units"); return r / o * i } function isNumber(r) { return !isNaN(r) && null !== r && !Array.isArray(r) } function isObject(r) { return !!r && r.constructor === Object } function validateBBox(r) { if (!r) throw new Error("bbox is required"); if (!Array.isArray(r)) throw new Error("bbox must be an Array"); if (4 !== r.length && 6 !== r.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); r.forEach(function (r) { if (!isNumber(r)) throw new Error("bbox must only contain numbers") }) } function validateId(r) { if (!r) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof r)) throw new Error("id must be a number or a string") } function radians2degrees() { throw new Error("method has been renamed to `radiansToDegrees`") } function degrees2radians() { throw new Error("method has been renamed to `degreesToRadians`") } function distanceToDegrees() { throw new Error("method has been renamed to `lengthToDegrees`") } function distanceToRadians() { throw new Error("method has been renamed to `lengthToRadians`") } function radiansToDistance() { throw new Error("method has been renamed to `radiansToLength`") } function bearingToAngle() { throw new Error("method has been renamed to `bearingToAzimuth`") } function convertDistance() { throw new Error("method has been renamed to `convertLength`") } Object.defineProperty(exports, "__esModule", { value: !0 }); var earthRadius = 6371008.8, factors = { meters: earthRadius, metres: earthRadius, millimeters: 1e3 * earthRadius, millimetres: 1e3 * earthRadius, centimeters: 100 * earthRadius, centimetres: 100 * earthRadius, kilometers: earthRadius / 1e3, kilometres: earthRadius / 1e3, miles: earthRadius / 1609.344, nauticalmiles: earthRadius / 1852, inches: 39.37 * earthRadius, yards: earthRadius / 1.0936, feet: 3.28084 * earthRadius, radians: 1, degrees: earthRadius / 111325 }, unitsFactors = { meters: 1, metres: 1, millimeters: 1e3, millimetres: 1e3, centimeters: 100, centimetres: 100, kilometers: .001, kilometres: .001, miles: 1 / 1609.344, nauticalmiles: 1 / 1852, inches: 39.37, yards: 1 / 1.0936, feet: 3.28084, radians: 1 / earthRadius, degrees: 1 / 111325 }, areaFactors = { meters: 1, metres: 1, millimeters: 1e6, millimetres: 1e6, centimeters: 1e4, centimetres: 1e4, kilometers: 1e-6, kilometres: 1e-6, acres: 247105e-9, miles: 3.86e-7, yards: 1.195990046, feet: 10.763910417, inches: 1550.003100006 }; exports.earthRadius = earthRadius, exports.factors = factors, exports.unitsFactors = unitsFactors, exports.areaFactors = areaFactors, exports.feature = feature, exports.geometry = geometry, exports.point = point, exports.points = points, exports.polygon = polygon, exports.polygons = polygons, exports.lineString = lineString, exports.lineStrings = lineStrings, exports.featureCollection = featureCollection, exports.multiLineString = multiLineString, exports.multiPoint = multiPoint, exports.multiPolygon = multiPolygon, exports.geometryCollection = geometryCollection, exports.round = round, exports.radiansToLength = radiansToLength, exports.lengthToRadians = lengthToRadians, exports.lengthToDegrees = lengthToDegrees, exports.bearingToAzimuth = bearingToAzimuth, exports.radiansToDegrees = radiansToDegrees, exports.degreesToRadians = degreesToRadians, exports.convertLength = convertLength, exports.convertArea = convertArea, exports.isNumber = isNumber, exports.isObject = isObject, exports.validateBBox = validateBBox, exports.validateId = validateId, exports.radians2degrees = radians2degrees, exports.degrees2radians = degrees2radians, exports.distanceToDegrees = distanceToDegrees, exports.distanceToRadians = distanceToRadians, exports.radiansToDistance = radiansToDistance, exports.bearingToAngle = bearingToAngle, exports.convertDistance = convertDistance;
//        }, {}], 7: [function (require, module, exports) {
//            "use strict"; function getCoord(e) { if (!e) throw new Error("obj is required"); var r = getCoords(e); if (r.length > 1 && helpers.isNumber(r[0]) && helpers.isNumber(r[1])) return r; throw new Error("Coordinate is not a valid Point") } function getCoords(e) { if (!e) throw new Error("obj is required"); var r; if (e.length ? r = e : e.coordinates ? r = e.coordinates : e.geometry && e.geometry.coordinates && (r = e.geometry.coordinates), r) return containsNumber(r), r; throw new Error("No valid coordinates") } function containsNumber(e) { if (e.length > 1 && helpers.isNumber(e[0]) && helpers.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return containsNumber(e[0]); throw new Error("coordinates must only contain numbers") } function geojsonType(e, r, o) { if (!r || !o) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.type) } function featureOf(e, r, o) { if (!e) throw new Error("No feature passed"); if (!o) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.geometry.type) } function collectionOf(e, r, o) { if (!e) throw new Error("No featureCollection passed"); if (!o) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + o + ", FeatureCollection required"); for (var t = 0; t < e.features.length; t++) { var n = e.features[t]; if (!n || "Feature" !== n.type || !n.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!n.geometry || n.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + n.geometry.type) } } function getGeom(e) { if (!e) throw new Error("geojson is required"); if (void 0 !== e.geometry) return e.geometry; if (e.coordinates || e.geometries) return e; throw new Error("geojson must be a valid Feature or Geometry Object") } function getGeomType() { throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType") } function getType(e, r) { if (!e) throw new Error((r || "geojson") + " is required"); if (e.geometry && e.geometry.type) return e.geometry.type; if (e.type) return e.type; throw new Error((r || "geojson") + " is invalid") } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.getCoord = getCoord, exports.getCoords = getCoords, exports.containsNumber = containsNumber, exports.geojsonType = geojsonType, exports.featureOf = featureOf, exports.collectionOf = collectionOf, exports.getGeom = getGeom, exports.getGeomType = getGeomType, exports.getType = getType;

//        }, { "@turf/helpers": 6 }], 8: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function length(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); if (!e) throw new Error("geojson is required"); return meta.segmentReduce(e, function (e, r) { var n = r.geometry.coordinates; return e + distance(n[0], n[1], t) }, 0) } var distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"), helpers = require("@turf/helpers"); module.exports = length, module.exports.default = length;

//        }, { "@turf/distance": 5, "@turf/helpers": 6, "@turf/meta": 9 }], 9: [function (require, module, exports) {
//            "use strict"; function coordEach(e, t, o) { if (null !== e) for (var r, n, c, i, a, u, l, s, f = 0, g = 0, p = e.type, h = "FeatureCollection" === p, d = "Feature" === p, y = h ? e.features.length : 1, m = 0; m < y; m++) { l = h ? e.features[m].geometry : d ? e.geometry : e, s = !!l && "GeometryCollection" === l.type, a = s ? l.geometries.length : 1; for (var E = 0; E < a; E++) { var v = 0, P = 0; if (null !== (i = s ? l.geometries[E] : l)) { u = i.coordinates; var R = i.type; switch (f = !o || "Polygon" !== R && "MultiPolygon" !== R ? 0 : 1, R) { case null: break; case "Point": t(u, g, m, v, P), g++, v++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++)t(u[r], g, m, v, P), g++, "MultiPoint" === R && v++; "LineString" === R && v++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (n = 0; n < u[r].length - f; n++)t(u[r][n], g, m, v, P), g++; "MultiLineString" === R && v++, "Polygon" === R && P++ } "Polygon" === R && v++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for ("MultiPolygon" === R && (P = 0), n = 0; n < u[r].length; n++) { for (c = 0; c < u[r][n].length - f; c++)t(u[r][n][c], g, m, v, P), g++; P++ } v++ } break; case "GeometryCollection": for (r = 0; r < i.geometries.length; r++)coordEach(i.geometries[r], t, o); break; default: throw new Error("Unknown Geometry Type") } } } } } function coordReduce(e, t, o, r) { var n = o; return coordEach(e, function (e, r, c, i, a) { n = 0 === r && void 0 === o ? e : t(n, e, r, c, i, a) }, r), n } function propEach(e, t) { var o; switch (e.type) { case "FeatureCollection": for (o = 0; o < e.features.length; o++)t(e.features[o].properties, o); break; case "Feature": t(e.properties, 0) } } function propReduce(e, t, o) { var r = o; return propEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function featureEach(e, t) { if ("Feature" === e.type) t(e, 0); else if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++)t(e.features[o], o) } function featureReduce(e, t, o) { var r = o; return featureEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function coordAll(e) { var t = []; return coordEach(e, function (e) { t.push(e) }), t } function geomEach(e, t) { var o, r, n, c, i, a, u, l, s, f, g = 0, p = "FeatureCollection" === e.type, h = "Feature" === e.type, d = p ? e.features.length : 1; for (o = 0; o < d; o++) { for (a = p ? e.features[o].geometry : h ? e.geometry : e, l = p ? e.features[o].properties : h ? e.properties : {}, s = p ? e.features[o].bbox : h ? e.bbox : void 0, f = p ? e.features[o].id : h ? e.id : void 0, u = !!a && "GeometryCollection" === a.type, i = u ? a.geometries.length : 1, n = 0; n < i; n++)if (null !== (c = u ? a.geometries[n] : a)) switch (c.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": t(c, g, l, s, f); break; case "GeometryCollection": for (r = 0; r < c.geometries.length; r++)t(c.geometries[r], g, l, s, f); break; default: throw new Error("Unknown Geometry Type") } else t(null, g, l, s, f); g++ } } function geomReduce(e, t, o) { var r = o; return geomEach(e, function (e, n, c, i, a) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i, a) }), r } function flattenEach(e, t) { geomEach(e, function (e, o, r, n, c) { var i = null === e ? null : e.type; switch (i) { case null: case "Point": case "LineString": case "Polygon": return void t(helpers.feature(e, r, { bbox: n, id: c }), o, 0) }var a; switch (i) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }e.coordinates.forEach(function (e, n) { var c = { type: a, coordinates: e }; t(helpers.feature(c, r), o, n) }) }) } function flattenReduce(e, t, o) { var r = o; return flattenEach(e, function (e, n, c) { r = 0 === n && 0 === c && void 0 === o ? e : t(r, e, n, c) }), r } function segmentEach(e, t) { flattenEach(e, function (e, o, r) { var n = 0; if (e.geometry) { var c = e.geometry.type; "Point" !== c && "MultiPoint" !== c && coordReduce(e, function (c, i, a, u, l, s) { var f = helpers.lineString([c, i], e.properties); return t(f, o, r, s, n), n++, i }) } }) } function segmentReduce(e, t, o) { var r = o, n = !1; return segmentEach(e, function (e, c, i, a, u) { r = !1 === n && void 0 === o ? e : t(r, e, c, i, a, u), n = !0 }), r } function lineEach(e, t) { if (!e) throw new Error("geojson is required"); flattenEach(e, function (e, o, r) { if (null !== e.geometry) { var n = e.geometry.type, c = e.geometry.coordinates; switch (n) { case "LineString": t(e, o, r, 0, 0); break; case "Polygon": for (var i = 0; i < c.length; i++)t(helpers.lineString(c[i], e.properties), o, r, i) } } }) } function lineReduce(e, t, o) { var r = o; return lineEach(e, function (e, n, c, i) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i) }), r } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.coordEach = coordEach, exports.coordReduce = coordReduce, exports.propEach = propEach, exports.propReduce = propReduce, exports.featureEach = featureEach, exports.featureReduce = featureReduce, exports.coordAll = coordAll, exports.geomEach = geomEach, exports.geomReduce = geomReduce, exports.flattenEach = flattenEach, exports.flattenReduce = flattenReduce, exports.segmentEach = segmentEach, exports.segmentReduce = segmentReduce, exports.lineEach = lineEach, exports.lineReduce = lineReduce;

//        }, { "@turf/helpers": 6 }], 10: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function nearestPoint(e, t) { if (!e) throw new Error("targetPoint is required"); if (!t) throw new Error("points is required"); var r, n = 1 / 0; return meta.featureEach(t, function (t, i) { var o = distance(e, t); o < n && (r = clone(t), r.properties.featureIndex = i, r.properties.distanceToPoint = o, n = o) }), r } var clone = _interopDefault(require("@turf/clone")), distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"); module.exports = nearestPoint, module.exports.default = nearestPoint;

//        }, { "@turf/clone": 3, "@turf/distance": 5, "@turf/meta": 9 }], 11: [function (require, module, exports) {
//            module.exports = { helpers: require("@turf/helpers"), along: require("@turf/along"), nearestPoint: require("@turf/nearest-point"), bearing: require("@turf/bearing"), length: require("@turf/length") };
//        }, { "@turf/along": 1, "@turf/bearing": 2, "@turf/helpers": 6, "@turf/length": 8, "@turf/nearest-point": 10 }]
//    }, {}, [11])(11)
//});

//(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.turf = f() } })(function () {
//    var define, module, exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
//        1: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function along(e, r, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var n; if ("Feature" === e.type) n = e.geometry.coordinates; else { if ("LineString" !== e.type) throw new Error("input must be a LineString Feature or Geometry"); n = e.coordinates } if (!helpers.isNumber(r)) throw new Error("distance must be a number"); for (var i = 0, o = 0; o < n.length && !(r >= i && o === n.length - 1); o++) { if (i >= r) { var a = r - i; if (a) { var u = bearing(n[o], n[o - 1]) - 180; return destination(n[o], a, u, t) } return helpers.point(n[o]) } i += measureDistance(n[o], n[o + 1], t) } return helpers.point(n[n.length - 1]) } var bearing = _interopDefault(require("@turf/bearing")), destination = _interopDefault(require("@turf/destination")), measureDistance = _interopDefault(require("@turf/distance")), helpers = require("@turf/helpers"); module.exports = along, module.exports.default = along;

//        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6 }], 2: [function (require, module, exports) {
//            "use strict"; function bearing(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); if (!0 === a.final) return calculateFinalBearing(e, r); var i = invariant.getCoord(e), n = invariant.getCoord(r), s = helpers.degreesToRadians(i[0]), t = helpers.degreesToRadians(n[0]), o = helpers.degreesToRadians(i[1]), l = helpers.degreesToRadians(n[1]), h = Math.sin(t - s) * Math.cos(l), d = Math.cos(o) * Math.sin(l) - Math.sin(o) * Math.cos(l) * Math.cos(t - s); return helpers.radiansToDegrees(Math.atan2(h, d)) } function calculateFinalBearing(e, r) { var a = bearing(r, e); return a = (a + 180) % 360 } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = bearing, module.exports.default = bearing;

//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 3: [function (require, module, exports) {
//            "use strict"; function clone(e) { if (!e) throw new Error("geojson is required"); switch (e.type) { case "Feature": return cloneFeature(e); case "FeatureCollection": return cloneFeatureCollection(e); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return cloneGeometry(e); default: throw new Error("unknown GeoJSON type") } } function cloneFeature(e) { var t = { type: "Feature" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "properties": case "geometry": return; default: t[o] = e[o] } }), t.properties = cloneProperties(e.properties), t.geometry = cloneGeometry(e.geometry), t } function cloneProperties(e) { var t = {}; return e ? (Object.keys(e).forEach(function (o) { var r = e[o]; "object" == typeof r ? null === r ? t[o] = null : r.length ? t[o] = r.map(function (e) { return e }) : t[o] = cloneProperties(r) : t[o] = r }), t) : t } function cloneFeatureCollection(e) { var t = { type: "FeatureCollection" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "features": return; default: t[o] = e[o] } }), t.features = e.features.map(function (e) { return cloneFeature(e) }), t } function cloneGeometry(e) { var t = { type: e.type }; return e.bbox && (t.bbox = e.bbox), "GeometryCollection" === e.type ? (t.geometries = e.geometries.map(function (e) { return cloneGeometry(e) }), t) : (t.coordinates = deepSlice(e.coordinates), t) } function deepSlice(e) { return "object" != typeof e[0] ? e.slice() : e.map(function (e) { return deepSlice(e) }) } module.exports = clone, module.exports.default = clone;

//        }, {}], 4: [function (require, module, exports) {
//            "use strict"; function destination(e, s, a, r) { if (r = r || {}, !helpers.isObject(r)) throw new Error("options is invalid"); var t = r.units, i = r.properties, n = invariant.getCoord(e), o = helpers.degreesToRadians(n[0]), h = helpers.degreesToRadians(n[1]), d = helpers.degreesToRadians(a), p = helpers.lengthToRadians(s, t), l = Math.asin(Math.sin(h) * Math.cos(p) + Math.cos(h) * Math.sin(p) * Math.cos(d)), M = o + Math.atan2(Math.sin(d) * Math.sin(p) * Math.cos(h), Math.cos(p) - Math.sin(h) * Math.sin(l)), u = helpers.radiansToDegrees(M), c = helpers.radiansToDegrees(l); return helpers.point([u, c], i) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = destination, module.exports.default = destination;

//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 5: [function (require, module, exports) {
//            "use strict"; function distance(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); var t = a.units, s = invariant.getCoord(e), i = invariant.getCoord(r), n = helpers.degreesToRadians(i[1] - s[1]), o = helpers.degreesToRadians(i[0] - s[0]), h = helpers.degreesToRadians(s[1]), d = helpers.degreesToRadians(i[1]), p = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(h) * Math.cos(d); return helpers.radiansToLength(2 * Math.atan2(Math.sqrt(p), Math.sqrt(1 - p)), t) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = distance, module.exports.default = distance;

//        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 6: [function (require, module, exports) {
//            "use strict"; function feature(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox, i = t.id; if (void 0 === r) throw new Error("geometry is required"); if (e && e.constructor !== Object) throw new Error("properties must be an Object"); o && validateBBox(o), i && validateId(i); var n = { type: "Feature" }; return i && (n.id = i), o && (n.bbox = o), n.properties = e || {}, n.geometry = r, n } function geometry(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox; if (!r) throw new Error("type is required"); if (!e) throw new Error("coordinates is required"); if (!Array.isArray(e)) throw new Error("coordinates must be an Array"); o && validateBBox(o); var i; switch (r) { case "Point": i = point(e).geometry; break; case "LineString": i = lineString(e).geometry; break; case "Polygon": i = polygon(e).geometry; break; case "MultiPoint": i = multiPoint(e).geometry; break; case "MultiLineString": i = multiLineString(e).geometry; break; case "MultiPolygon": i = multiPolygon(e).geometry; break; default: throw new Error(r + " is invalid") }return o && (i.bbox = o), i } function point(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); if (r.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!isNumber(r[0]) || !isNumber(r[1])) throw new Error("coordinates must contain numbers"); return feature({ type: "Point", coordinates: r }, e, t) } function points(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return point(r, e) }), t) } function polygon(r, e, t) { if (!r) throw new Error("coordinates is required"); for (var o = 0; o < r.length; o++) { var i = r[o]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var n = 0; n < i[i.length - 1].length; n++) { if (0 === o && 0 === n && !isNumber(i[0][0]) || !isNumber(i[0][1])) throw new Error("coordinates must contain numbers"); if (i[i.length - 1][n] !== i[0][n]) throw new Error("First and last Position are not equivalent.") } } return feature({ type: "Polygon", coordinates: r }, e, t) } function polygons(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return polygon(r, e) }), t) } function lineString(r, e, t) { if (!r) throw new Error("coordinates is required"); if (r.length < 2) throw new Error("coordinates must be an array of two or more positions"); if (!isNumber(r[0][1]) || !isNumber(r[0][1])) throw new Error("coordinates must contain numbers"); return feature({ type: "LineString", coordinates: r }, e, t) } function lineStrings(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return lineString(r, e) }), t) } function featureCollection(r, e) { if (e = e || {}, !isObject(e)) throw new Error("options is invalid"); var t = e.bbox, o = e.id; if (!r) throw new Error("No features passed"); if (!Array.isArray(r)) throw new Error("features must be an Array"); t && validateBBox(t), o && validateId(o); var i = { type: "FeatureCollection" }; return o && (i.id = o), t && (i.bbox = t), i.features = r, i } function multiLineString(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiLineString", coordinates: r }, e, t) } function multiPoint(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPoint", coordinates: r }, e, t) } function multiPolygon(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPolygon", coordinates: r }, e, t) } function geometryCollection(r, e, t) { if (!r) throw new Error("geometries is required"); if (!Array.isArray(r)) throw new Error("geometries must be an Array"); return feature({ type: "GeometryCollection", geometries: r }, e, t) } function round(r, e) { if (void 0 === r || null === r || isNaN(r)) throw new Error("num is required"); if (e && !(e >= 0)) throw new Error("precision must be a positive number"); var t = Math.pow(10, e || 0); return Math.round(r * t) / t } function radiansToLength(r, e) { if (void 0 === r || null === r) throw new Error("radians is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r * t } function lengthToRadians(r, e) { if (void 0 === r || null === r) throw new Error("distance is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r / t } function lengthToDegrees(r, e) { return radiansToDegrees(lengthToRadians(r, e)) } function bearingToAzimuth(r) { if (null === r || void 0 === r) throw new Error("bearing is required"); var e = r % 360; return e < 0 && (e += 360), e } function radiansToDegrees(r) { if (null === r || void 0 === r) throw new Error("radians is required"); return r % (2 * Math.PI) * 180 / Math.PI } function degreesToRadians(r) { if (null === r || void 0 === r) throw new Error("degrees is required"); return r % 360 * Math.PI / 180 } function convertLength(r, e, t) { if (null === r || void 0 === r) throw new Error("length is required"); if (!(r >= 0)) throw new Error("length must be a positive number"); return radiansToLength(lengthToRadians(r, e), t || "kilometers") } function convertArea(r, e, t) { if (null === r || void 0 === r) throw new Error("area is required"); if (!(r >= 0)) throw new Error("area must be a positive number"); var o = areaFactors[e || "meters"]; if (!o) throw new Error("invalid original units"); var i = areaFactors[t || "kilometers"]; if (!i) throw new Error("invalid final units"); return r / o * i } function isNumber(r) { return !isNaN(r) && null !== r && !Array.isArray(r) } function isObject(r) { return !!r && r.constructor === Object } function validateBBox(r) { if (!r) throw new Error("bbox is required"); if (!Array.isArray(r)) throw new Error("bbox must be an Array"); if (4 !== r.length && 6 !== r.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); r.forEach(function (r) { if (!isNumber(r)) throw new Error("bbox must only contain numbers") }) } function validateId(r) { if (!r) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof r)) throw new Error("id must be a number or a string") } function radians2degrees() { throw new Error("method has been renamed to `radiansToDegrees`") } function degrees2radians() { throw new Error("method has been renamed to `degreesToRadians`") } function distanceToDegrees() { throw new Error("method has been renamed to `lengthToDegrees`") } function distanceToRadians() { throw new Error("method has been renamed to `lengthToRadians`") } function radiansToDistance() { throw new Error("method has been renamed to `radiansToLength`") } function bearingToAngle() { throw new Error("method has been renamed to `bearingToAzimuth`") } function convertDistance() { throw new Error("method has been renamed to `convertLength`") } Object.defineProperty(exports, "__esModule", { value: !0 }); var earthRadius = 6371008.8, factors = { meters: earthRadius, metres: earthRadius, millimeters: 1e3 * earthRadius, millimetres: 1e3 * earthRadius, centimeters: 100 * earthRadius, centimetres: 100 * earthRadius, kilometers: earthRadius / 1e3, kilometres: earthRadius / 1e3, miles: earthRadius / 1609.344, nauticalmiles: earthRadius / 1852, inches: 39.37 * earthRadius, yards: earthRadius / 1.0936, feet: 3.28084 * earthRadius, radians: 1, degrees: earthRadius / 111325 }, unitsFactors = { meters: 1, metres: 1, millimeters: 1e3, millimetres: 1e3, centimeters: 100, centimetres: 100, kilometers: .001, kilometres: .001, miles: 1 / 1609.344, nauticalmiles: 1 / 1852, inches: 39.37, yards: 1 / 1.0936, feet: 3.28084, radians: 1 / earthRadius, degrees: 1 / 111325 }, areaFactors = { meters: 1, metres: 1, millimeters: 1e6, millimetres: 1e6, centimeters: 1e4, centimetres: 1e4, kilometers: 1e-6, kilometres: 1e-6, acres: 247105e-9, miles: 3.86e-7, yards: 1.195990046, feet: 10.763910417, inches: 1550.003100006 }; exports.earthRadius = earthRadius, exports.factors = factors, exports.unitsFactors = unitsFactors, exports.areaFactors = areaFactors, exports.feature = feature, exports.geometry = geometry, exports.point = point, exports.points = points, exports.polygon = polygon, exports.polygons = polygons, exports.lineString = lineString, exports.lineStrings = lineStrings, exports.featureCollection = featureCollection, exports.multiLineString = multiLineString, exports.multiPoint = multiPoint, exports.multiPolygon = multiPolygon, exports.geometryCollection = geometryCollection, exports.round = round, exports.radiansToLength = radiansToLength, exports.lengthToRadians = lengthToRadians, exports.lengthToDegrees = lengthToDegrees, exports.bearingToAzimuth = bearingToAzimuth, exports.radiansToDegrees = radiansToDegrees, exports.degreesToRadians = degreesToRadians, exports.convertLength = convertLength, exports.convertArea = convertArea, exports.isNumber = isNumber, exports.isObject = isObject, exports.validateBBox = validateBBox, exports.validateId = validateId, exports.radians2degrees = radians2degrees, exports.degrees2radians = degrees2radians, exports.distanceToDegrees = distanceToDegrees, exports.distanceToRadians = distanceToRadians, exports.radiansToDistance = radiansToDistance, exports.bearingToAngle = bearingToAngle, exports.convertDistance = convertDistance;

//        }, {}], 7: [function (require, module, exports) {
//            "use strict"; function getCoord(e) { if (!e) throw new Error("obj is required"); var r = getCoords(e); if (r.length > 1 && helpers.isNumber(r[0]) && helpers.isNumber(r[1])) return r; throw new Error("Coordinate is not a valid Point") } function getCoords(e) { if (!e) throw new Error("obj is required"); var r; if (e.length ? r = e : e.coordinates ? r = e.coordinates : e.geometry && e.geometry.coordinates && (r = e.geometry.coordinates), r) return containsNumber(r), r; throw new Error("No valid coordinates") } function containsNumber(e) { if (e.length > 1 && helpers.isNumber(e[0]) && helpers.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return containsNumber(e[0]); throw new Error("coordinates must only contain numbers") } function geojsonType(e, r, o) { if (!r || !o) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.type) } function featureOf(e, r, o) { if (!e) throw new Error("No feature passed"); if (!o) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.geometry.type) } function collectionOf(e, r, o) { if (!e) throw new Error("No featureCollection passed"); if (!o) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + o + ", FeatureCollection required"); for (var t = 0; t < e.features.length; t++) { var n = e.features[t]; if (!n || "Feature" !== n.type || !n.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!n.geometry || n.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + n.geometry.type) } } function getGeom(e) { if (!e) throw new Error("geojson is required"); if (void 0 !== e.geometry) return e.geometry; if (e.coordinates || e.geometries) return e; throw new Error("geojson must be a valid Feature or Geometry Object") } function getGeomType() { throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType") } function getType(e, r) { if (!e) throw new Error((r || "geojson") + " is required"); if (e.geometry && e.geometry.type) return e.geometry.type; if (e.type) return e.type; throw new Error((r || "geojson") + " is invalid") } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.getCoord = getCoord, exports.getCoords = getCoords, exports.containsNumber = containsNumber, exports.geojsonType = geojsonType, exports.featureOf = featureOf, exports.collectionOf = collectionOf, exports.getGeom = getGeom, exports.getGeomType = getGeomType, exports.getType = getType;
//        }, { "@turf/helpers": 6 }], 8: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function length(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); if (!e) throw new Error("geojson is required"); return meta.segmentReduce(e, function (e, r) { var n = r.geometry.coordinates; return e + distance(n[0], n[1], t) }, 0) } var distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"), helpers = require("@turf/helpers"); module.exports = length, module.exports.default = length;

//        }, { "@turf/distance": 5, "@turf/helpers": 6, "@turf/meta": 13 }], 9: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineIntersect(e, t) { var r = {}, n = []; if ("LineString" === e.type && (e = helpers.feature(e)), "LineString" === t.type && (t = helpers.feature(t)), "Feature" === e.type && "Feature" === t.type && "LineString" === e.geometry.type && "LineString" === t.geometry.type && 2 === e.geometry.coordinates.length && 2 === t.geometry.coordinates.length) { var i = intersects(e, t); return i && n.push(i), helpers.featureCollection(n) } var o = rbush(); return o.load(lineSegment(t)), meta.featureEach(lineSegment(e), function (e) { meta.featureEach(o.search(e), function (t) { var i = intersects(e, t); if (i) { var o = invariant.getCoords(i).join(","); r[o] || (r[o] = !0, n.push(i)) } }) }), helpers.featureCollection(n) } function intersects(e, t) { var r = invariant.getCoords(e), n = invariant.getCoords(t); if (2 !== r.length) throw new Error("<intersects> line1 must only contain 2 coordinates"); if (2 !== n.length) throw new Error("<intersects> line2 must only contain 2 coordinates"); var i = r[0][0], o = r[0][1], a = r[1][0], u = r[1][1], s = n[0][0], l = n[0][1], f = n[1][0], c = n[1][1], p = (c - l) * (a - i) - (f - s) * (u - o), h = (f - s) * (o - l) - (c - l) * (i - s), g = (a - i) * (o - l) - (u - o) * (i - s); if (0 === p) return null; var m = h / p, v = g / p; if (m >= 0 && m <= 1 && v >= 0 && v <= 1) { var d = i + m * (a - i), y = o + m * (u - o); return helpers.point([d, y]) } return null } var rbush = _interopDefault(require("geojson-rbush")), lineSegment = _interopDefault(require("@turf/line-segment")), invariant = require("@turf/invariant"), meta = require("@turf/meta"), helpers = require("@turf/helpers"); module.exports = lineIntersect, module.exports.default = lineIntersect;
//        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/line-segment": 10, "@turf/meta": 13, "geojson-rbush": 22 }], 10: [function (require, module, exports) {
//            "use strict"; function lineSegment(e) { if (!e) throw new Error("geojson is required"); var r = []; return meta.flattenEach(e, function (e) { lineSegmentFeature(e, r) }), helpers.featureCollection(r) } function lineSegmentFeature(e, r) { var t = [], n = e.geometry; switch (n.type) { case "Polygon": t = invariant.getCoords(n); break; case "LineString": t = [invariant.getCoords(n)] }t.forEach(function (t) { createSegments(t, e.properties).forEach(function (e) { e.id = r.length, r.push(e) }) }) } function createSegments(e, r) { var t = []; return e.reduce(function (e, n) { var i = helpers.lineString([e, n], r); return i.bbox = bbox(e, n), t.push(i), n }), t } function bbox(e, r) { var t = e[0], n = e[1], i = r[0], o = r[1]; return [t < i ? t : i, n < o ? n : o, t > i ? t : i, n > o ? n : o] } var helpers = require("@turf/helpers"), invariant = require("@turf/invariant"), meta = require("@turf/meta"); module.exports = lineSegment, module.exports.default = lineSegment;
//        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/meta": 13 }], 11: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineSliceAlong(e, r, t, i) { if (i = i || {}, !helpers.isObject(i)) throw new Error("options is invalid"); var n, o = []; if ("Feature" === e.type) n = e.geometry.coordinates; else { if ("LineString" !== e.type) throw new Error("input must be a LineString Feature or Geometry"); n = e.coordinates } for (var l, u, s, a = 0, p = 0; p < n.length && !(r >= a && p === n.length - 1); p++) { if (a > r && 0 === o.length) { if (!(l = r - a)) return o.push(n[p]), helpers.lineString(o); u = bearing(n[p], n[p - 1]) - 180, s = destination(n[p], l, u, i), o.push(s.geometry.coordinates) } if (a >= t) return (l = t - a) ? (u = bearing(n[p], n[p - 1]) - 180, s = destination(n[p], l, u, i), o.push(s.geometry.coordinates), helpers.lineString(o)) : (o.push(n[p]), helpers.lineString(o)); if (a >= r && o.push(n[p]), p === n.length - 1) return helpers.lineString(o); a += distance(n[p], n[p + 1], i) } return helpers.lineString(n[n.length - 1]) } var bearing = _interopDefault(require("@turf/bearing")), distance = _interopDefault(require("@turf/distance")), destination = _interopDefault(require("@turf/destination")), helpers = require("@turf/helpers"); module.exports = lineSliceAlong, module.exports.default = lineSliceAlong;

//        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6 }], 12: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineSlice(e, r, i) { var n = invariant.getCoords(i); if ("LineString" !== invariant.getType(i)) throw new Error("line must be a LineString"); var t, o = nearestPointOnLine(i, e), a = nearestPointOnLine(i, r); t = o.properties.index <= a.properties.index ? [o, a] : [a, o]; for (var p = [t[0].geometry.coordinates], s = t[0].properties.index + 1; s < t[1].properties.index + 1; s++)p.push(n[s]); return p.push(t[1].geometry.coordinates), helpers.lineString(p, i.properties) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"), nearestPointOnLine = _interopDefault(require("@turf/nearest-point-on-line")); module.exports = lineSlice, module.exports.default = lineSlice;
//        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/nearest-point-on-line": 14 }], 13: [function (require, module, exports) {
//            "use strict"; function coordEach(e, t, o) { if (null !== e) for (var r, n, c, i, a, u, l, s, f = 0, g = 0, p = e.type, h = "FeatureCollection" === p, d = "Feature" === p, y = h ? e.features.length : 1, m = 0; m < y; m++) { l = h ? e.features[m].geometry : d ? e.geometry : e, s = !!l && "GeometryCollection" === l.type, a = s ? l.geometries.length : 1; for (var E = 0; E < a; E++) { var v = 0, P = 0; if (null !== (i = s ? l.geometries[E] : l)) { u = i.coordinates; var R = i.type; switch (f = !o || "Polygon" !== R && "MultiPolygon" !== R ? 0 : 1, R) { case null: break; case "Point": t(u, g, m, v, P), g++, v++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++)t(u[r], g, m, v, P), g++, "MultiPoint" === R && v++; "LineString" === R && v++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (n = 0; n < u[r].length - f; n++)t(u[r][n], g, m, v, P), g++; "MultiLineString" === R && v++, "Polygon" === R && P++ } "Polygon" === R && v++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for ("MultiPolygon" === R && (P = 0), n = 0; n < u[r].length; n++) { for (c = 0; c < u[r][n].length - f; c++)t(u[r][n][c], g, m, v, P), g++; P++ } v++ } break; case "GeometryCollection": for (r = 0; r < i.geometries.length; r++)coordEach(i.geometries[r], t, o); break; default: throw new Error("Unknown Geometry Type") } } } } } function coordReduce(e, t, o, r) { var n = o; return coordEach(e, function (e, r, c, i, a) { n = 0 === r && void 0 === o ? e : t(n, e, r, c, i, a) }, r), n } function propEach(e, t) { var o; switch (e.type) { case "FeatureCollection": for (o = 0; o < e.features.length; o++)t(e.features[o].properties, o); break; case "Feature": t(e.properties, 0) } } function propReduce(e, t, o) { var r = o; return propEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function featureEach(e, t) { if ("Feature" === e.type) t(e, 0); else if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++)t(e.features[o], o) } function featureReduce(e, t, o) { var r = o; return featureEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function coordAll(e) { var t = []; return coordEach(e, function (e) { t.push(e) }), t } function geomEach(e, t) { var o, r, n, c, i, a, u, l, s, f, g = 0, p = "FeatureCollection" === e.type, h = "Feature" === e.type, d = p ? e.features.length : 1; for (o = 0; o < d; o++) { for (a = p ? e.features[o].geometry : h ? e.geometry : e, l = p ? e.features[o].properties : h ? e.properties : {}, s = p ? e.features[o].bbox : h ? e.bbox : void 0, f = p ? e.features[o].id : h ? e.id : void 0, u = !!a && "GeometryCollection" === a.type, i = u ? a.geometries.length : 1, n = 0; n < i; n++)if (null !== (c = u ? a.geometries[n] : a)) switch (c.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": t(c, g, l, s, f); break; case "GeometryCollection": for (r = 0; r < c.geometries.length; r++)t(c.geometries[r], g, l, s, f); break; default: throw new Error("Unknown Geometry Type") } else t(null, g, l, s, f); g++ } } function geomReduce(e, t, o) { var r = o; return geomEach(e, function (e, n, c, i, a) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i, a) }), r } function flattenEach(e, t) { geomEach(e, function (e, o, r, n, c) { var i = null === e ? null : e.type; switch (i) { case null: case "Point": case "LineString": case "Polygon": return void t(helpers.feature(e, r, { bbox: n, id: c }), o, 0) }var a; switch (i) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }e.coordinates.forEach(function (e, n) { var c = { type: a, coordinates: e }; t(helpers.feature(c, r), o, n) }) }) } function flattenReduce(e, t, o) { var r = o; return flattenEach(e, function (e, n, c) { r = 0 === n && 0 === c && void 0 === o ? e : t(r, e, n, c) }), r } function segmentEach(e, t) { flattenEach(e, function (e, o, r) { var n = 0; if (e.geometry) { var c = e.geometry.type; "Point" !== c && "MultiPoint" !== c && coordReduce(e, function (c, i, a, u, l, s) { var f = helpers.lineString([c, i], e.properties); return t(f, o, r, s, n), n++, i }) } }) } function segmentReduce(e, t, o) { var r = o, n = !1; return segmentEach(e, function (e, c, i, a, u) { r = !1 === n && void 0 === o ? e : t(r, e, c, i, a, u), n = !0 }), r } function lineEach(e, t) { if (!e) throw new Error("geojson is required"); flattenEach(e, function (e, o, r) { if (null !== e.geometry) { var n = e.geometry.type, c = e.geometry.coordinates; switch (n) { case "LineString": t(e, o, r, 0, 0); break; case "Polygon": for (var i = 0; i < c.length; i++)t(helpers.lineString(c[i], e.properties), o, r, i) } } }) } function lineReduce(e, t, o) { var r = o; return lineEach(e, function (e, n, c, i) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i) }), r } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.coordEach = coordEach, exports.coordReduce = coordReduce, exports.propEach = propEach, exports.propReduce = propReduce, exports.featureEach = featureEach, exports.featureReduce = featureReduce, exports.coordAll = coordAll, exports.geomEach = geomEach, exports.geomReduce = geomReduce, exports.flattenEach = flattenEach, exports.flattenReduce = flattenReduce, exports.segmentEach = segmentEach, exports.segmentReduce = segmentReduce, exports.lineEach = lineEach, exports.lineReduce = lineReduce;

//        }, { "@turf/helpers": 6 }], 14: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function nearestPointOnLine(e, t, r) { if (r = r || {}, !helpers.isObject(r)) throw new Error("options is invalid"); var i = e.geometry ? e.geometry.type : e.type; if ("LineString" !== i && "MultiLineString" !== i) throw new Error("lines must be LineString or MultiLineString"); var n = helpers.point([1 / 0, 1 / 0], { dist: 1 / 0 }), s = 0; return meta.flattenEach(e, function (e) { for (var i = invariant.getCoords(e), o = 0; o < i.length - 1; o++) { var p = helpers.point(i[o]); p.properties.dist = distance(t, p, r); var a = helpers.point(i[o + 1]); a.properties.dist = distance(t, a, r); var d = distance(p, a, r), u = Math.max(p.properties.dist, a.properties.dist), l = bearing(p, a), f = destination(t, u, l + 90, r), c = destination(t, u, l - 90, r), g = lineIntersects(helpers.lineString([f.geometry.coordinates, c.geometry.coordinates]), helpers.lineString([p.geometry.coordinates, a.geometry.coordinates])), h = null; g.features.length > 0 && (h = g.features[0], h.properties.dist = distance(t, h, r), h.properties.location = s + distance(p, h, r)), p.properties.dist < n.properties.dist && (n = p, n.properties.index = o, n.properties.location = s), a.properties.dist < n.properties.dist && (n = a, n.properties.index = o + 1, n.properties.location = s + d), h && h.properties.dist < n.properties.dist && (n = h, n.properties.index = o), s += d } }), n } var bearing = _interopDefault(require("@turf/bearing")), distance = _interopDefault(require("@turf/distance")), destination = _interopDefault(require("@turf/destination")), lineIntersects = _interopDefault(require("@turf/line-intersect")), meta = require("@turf/meta"), helpers = require("@turf/helpers"), invariant = require("@turf/invariant"); module.exports = nearestPointOnLine, module.exports.default = nearestPointOnLine;

//        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6, "@turf/invariant": 7, "@turf/line-intersect": 9, "@turf/meta": 13 }], 15: [function (require, module, exports) {
//            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function nearestPoint(e, t) { if (!e) throw new Error("targetPoint is required"); if (!t) throw new Error("points is required"); var r, n = 1 / 0; return meta.featureEach(t, function (t, i) { var o = distance(e, t); o < n && (r = clone(t), r.properties.featureIndex = i, r.properties.distanceToPoint = o, n = o) }), r } var clone = _interopDefault(require("@turf/clone")), distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"); module.exports = nearestPoint, module.exports.default = nearestPoint;

//        }, { "@turf/clone": 3, "@turf/distance": 5, "@turf/meta": 13 }], 16: [function (require, module, exports) {
//            "use strict"; function pointToLineDistance(e, t, r) { if (void 0 === r && (r = {}), r.method || (r.method = "geodesic"), r.units || (r.units = "kilometers"), !e) throw new Error("pt is required"); if (Array.isArray(e) ? e = helpers_1.point(e) : "Point" === e.type ? e = helpers_1.feature(e) : invariant_1.featureOf(e, "Point", "point"), !t) throw new Error("line is required"); Array.isArray(t) ? t = helpers_1.lineString(t) : "LineString" === t.type ? t = helpers_1.feature(t) : invariant_1.featureOf(t, "LineString", "line"); var i = 1 / 0, n = e.geometry.coordinates; return meta_1.segmentEach(t, function (e) { var t = e.geometry.coordinates[0], a = e.geometry.coordinates[1], o = distanceToSegment(n, t, a, r); o < i && (i = o) }), helpers_1.convertLength(i, "degrees", r.units) } function distanceToSegment(e, t, r, i) { var n = [r[0] - t[0], r[1] - t[1]], a = [e[0] - t[0], e[1] - t[1]], o = dot(a, n); if (o <= 0) return calcDistance(e, t, { method: i.method, units: "degrees" }); var s = dot(n, n); if (s <= o) return calcDistance(e, r, { method: i.method, units: "degrees" }); var u = o / s; return calcDistance(e, [t[0] + u * n[0], t[1] + u * n[1]], { method: i.method, units: "degrees" }) } function dot(e, t) { return e[0] * t[0] + e[1] * t[1] } function calcDistance(e, t, r) { return "planar" === r.method ? rhumb_distance_1.default(e, t, r) : distance_1.default(e, t, r) } Object.defineProperty(exports, "__esModule", { value: !0 }); var invariant_1 = require("@turf/invariant"), meta_1 = require("@turf/meta"), distance_1 = require("@turf/distance"), rhumb_distance_1 = require("@turf/rhumb-distance"), helpers_1 = require("@turf/helpers"); exports.default = pointToLineDistance;

//        }, { "@turf/distance": 17, "@turf/helpers": 18, "@turf/invariant": 19, "@turf/meta": 20, "@turf/rhumb-distance": 21 }], 17: [function (require, module, exports) {
//            "use strict"; function distance(e, a, r) { void 0 === r && (r = {}); var t = invariant_1.getCoord(e), s = invariant_1.getCoord(a), i = helpers_1.degreesToRadians(s[1] - t[1]), n = helpers_1.degreesToRadians(s[0] - t[0]), o = helpers_1.degreesToRadians(t[1]), d = helpers_1.degreesToRadians(s[1]), h = Math.pow(Math.sin(i / 2), 2) + Math.pow(Math.sin(n / 2), 2) * Math.cos(o) * Math.cos(d); return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), r.units) } Object.defineProperty(exports, "__esModule", { value: !0 }); var invariant_1 = require("@turf/invariant"), helpers_1 = require("@turf/helpers"); exports.default = distance;

//        }, { "@turf/helpers": 18, "@turf/invariant": 19 }], 18: [function (require, module, exports) {
//            "use strict"; function feature(e, r, t) { void 0 === t && (t = {}); var o = { type: "Feature" }; return (0 === t.id || t.id) && (o.id = t.id), t.bbox && (o.bbox = t.bbox), o.properties = r || {}, o.geometry = e, o } function geometry(e, r, t) { switch (void 0 === t && (t = {}), e) { case "Point": return point(r).geometry; case "LineString": return lineString(r).geometry; case "Polygon": return polygon(r).geometry; case "MultiPoint": return multiPoint(r).geometry; case "MultiLineString": return multiLineString(r).geometry; case "MultiPolygon": return multiPolygon(r).geometry; default: throw new Error(e + " is invalid") } } function point(e, r, t) { return void 0 === t && (t = {}), feature({ type: "Point", coordinates: e }, r, t) } function points(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return point(e, r) }), t) } function polygon(e, r, t) { void 0 === t && (t = {}); for (var o = 0, n = e; o < n.length; o++) { var i = n[o]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var s = 0; s < i[i.length - 1].length; s++)if (i[i.length - 1][s] !== i[0][s]) throw new Error("First and last Position are not equivalent.") } return feature({ type: "Polygon", coordinates: e }, r, t) } function polygons(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return polygon(e, r) }), t) } function lineString(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return feature({ type: "LineString", coordinates: e }, r, t) } function lineStrings(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return lineString(e, r) }), t) } function featureCollection(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function multiLineString(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiLineString", coordinates: e }, r, t) } function multiPoint(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiPoint", coordinates: e }, r, t) } function multiPolygon(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiPolygon", coordinates: e }, r, t) } function geometryCollection(e, r, t) { return void 0 === t && (t = {}), feature({ type: "GeometryCollection", geometries: e }, r, t) } function round(e, r) { if (void 0 === r && (r = 0), r && !(r >= 0)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t } function radiansToLength(e, r) { void 0 === r && (r = "kilometers"); var t = exports.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function lengthToRadians(e, r) { void 0 === r && (r = "kilometers"); var t = exports.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function lengthToDegrees(e, r) { return radiansToDegrees(lengthToRadians(e, r)) } function bearingToAzimuth(e) { var r = e % 360; return r < 0 && (r += 360), r } function radiansToDegrees(e) { return e % (2 * Math.PI) * 180 / Math.PI } function degreesToRadians(e) { return e % 360 * Math.PI / 180 } function convertLength(e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(e >= 0)) throw new Error("length must be a positive number"); return radiansToLength(lengthToRadians(e, r), t) } function convertArea(e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(e >= 0)) throw new Error("area must be a positive number"); var o = exports.areaFactors[r]; if (!o) throw new Error("invalid original units"); var n = exports.areaFactors[t]; if (!n) throw new Error("invalid final units"); return e / o * n } function isNumber(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } function isObject(e) { return !!e && e.constructor === Object } function validateBBox(e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!isNumber(e)) throw new Error("bbox must only contain numbers") }) } function validateId(e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") } function radians2degrees() { throw new Error("method has been renamed to `radiansToDegrees`") } function degrees2radians() { throw new Error("method has been renamed to `degreesToRadians`") } function distanceToDegrees() { throw new Error("method has been renamed to `lengthToDegrees`") } function distanceToRadians() { throw new Error("method has been renamed to `lengthToRadians`") } function radiansToDistance() { throw new Error("method has been renamed to `radiansToLength`") } function bearingToAngle() { throw new Error("method has been renamed to `bearingToAzimuth`") } function convertDistance() { throw new Error("method has been renamed to `convertLength`") } Object.defineProperty(exports, "__esModule", { value: !0 }), exports.earthRadius = 6371008.8, exports.factors = { centimeters: 100 * exports.earthRadius, centimetres: 100 * exports.earthRadius, degrees: exports.earthRadius / 111325, feet: 3.28084 * exports.earthRadius, inches: 39.37 * exports.earthRadius, kilometers: exports.earthRadius / 1e3, kilometres: exports.earthRadius / 1e3, meters: exports.earthRadius, metres: exports.earthRadius, miles: exports.earthRadius / 1609.344, millimeters: 1e3 * exports.earthRadius, millimetres: 1e3 * exports.earthRadius, nauticalmiles: exports.earthRadius / 1852, radians: 1, yards: exports.earthRadius / 1.0936 }, exports.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / exports.earthRadius, yards: 1 / 1.0936 }, exports.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 3.86e-7, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, exports.feature = feature, exports.geometry = geometry, exports.point = point, exports.points = points, exports.polygon = polygon, exports.polygons = polygons, exports.lineString = lineString, exports.lineStrings = lineStrings, exports.featureCollection = featureCollection, exports.multiLineString = multiLineString, exports.multiPoint = multiPoint, exports.multiPolygon = multiPolygon, exports.geometryCollection = geometryCollection, exports.round = round, exports.radiansToLength = radiansToLength, exports.lengthToRadians = lengthToRadians, exports.lengthToDegrees = lengthToDegrees, exports.bearingToAzimuth = bearingToAzimuth, exports.radiansToDegrees = radiansToDegrees, exports.degreesToRadians = degreesToRadians, exports.convertLength = convertLength, exports.convertArea = convertArea, exports.isNumber = isNumber, exports.isObject = isObject, exports.validateBBox = validateBBox, exports.validateId = validateId, exports.radians2degrees = radians2degrees, exports.degrees2radians = degrees2radians, exports.distanceToDegrees = distanceToDegrees, exports.distanceToRadians = distanceToRadians, exports.radiansToDistance = radiansToDistance, exports.bearingToAngle = bearingToAngle, exports.convertDistance = convertDistance;

//        }, {}], 19: [function (require, module, exports) {
//            "use strict"; function getCoord(e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") } function getCoords(e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") } function containsNumber(e) { if (e.length > 1 && helpers_1.isNumber(e[0]) && helpers_1.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return containsNumber(e[0]); throw new Error("coordinates must only contain numbers") } function geojsonType(e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) } function featureOf(e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) } function collectionOf(e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var o = 0, n = e.features; o < n.length; o++) { var i = n[o]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } } function getGeom(e) { return "Feature" === e.type ? e.geometry : e } function getType(e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers_1 = require("@turf/helpers"); exports.getCoord = getCoord, exports.getCoords = getCoords, exports.containsNumber = containsNumber, exports.geojsonType = geojsonType, exports.featureOf = featureOf, exports.collectionOf = collectionOf, exports.getGeom = getGeom, exports.getType = getType;
//        }, { "@turf/helpers": 18 }], 20: [function (require, module, exports) {
//            "use strict"; function coordEach(e, t, r) { if (null !== e) for (var n, o, i, a, l, u, c, s, g = 0, f = 0, h = e.type, p = "FeatureCollection" === h, d = "Feature" === h, y = p ? e.features.length : 1, m = 0; m < y; m++) { c = p ? e.features[m].geometry : d ? e.geometry : e, s = !!c && "GeometryCollection" === c.type, l = s ? c.geometries.length : 1; for (var v = 0; v < l; v++) { var E = 0, P = 0; if (null !== (a = s ? c.geometries[v] : c)) { u = a.coordinates; var w = a.type; switch (g = !r || "Polygon" !== w && "MultiPolygon" !== w ? 0 : 1, w) { case null: break; case "Point": if (!1 === t(u, f, m, E, P)) return !1; f++, E++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === t(u[n], f, m, E, P)) return !1; f++, "MultiPoint" === w && E++ } "LineString" === w && E++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - g; o++) { if (!1 === t(u[n][o], f, m, E, P)) return !1; f++ } "MultiLineString" === w && E++, "Polygon" === w && P++ } "Polygon" === w && E++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (P = 0, o = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - g; i++) { if (!1 === t(u[n][o][i], f, m, E, P)) return !1; f++ } P++ } E++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === coordEach(a.geometries[n], t, r)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function coordReduce(e, t, r, n) { var o = r; return coordEach(e, function (e, n, i, a, l) { o = 0 === n && void 0 === r ? e : t(o, e, n, i, a, l) }, n), o } function propEach(e, t) { var r; switch (e.type) { case "FeatureCollection": for (r = 0; r < e.features.length && !1 !== t(e.features[r].properties, r); r++); break; case "Feature": t(e.properties, 0) } } function propReduce(e, t, r) { var n = r; return propEach(e, function (e, o) { n = 0 === o && void 0 === r ? e : t(n, e, o) }), n } function featureEach(e, t) { if ("Feature" === e.type) t(e, 0); else if ("FeatureCollection" === e.type) for (var r = 0; r < e.features.length && !1 !== t(e.features[r], r); r++); } function featureReduce(e, t, r) { var n = r; return featureEach(e, function (e, o) { n = 0 === o && void 0 === r ? e : t(n, e, o) }), n } function coordAll(e) { var t = []; return coordEach(e, function (e) { t.push(e) }), t } function geomEach(e, t) { var r, n, o, i, a, l, u, c, s, g, f = 0, h = "FeatureCollection" === e.type, p = "Feature" === e.type, d = h ? e.features.length : 1; for (r = 0; r < d; r++) { for (l = h ? e.features[r].geometry : p ? e.geometry : e, c = h ? e.features[r].properties : p ? e.properties : {}, s = h ? e.features[r].bbox : p ? e.bbox : void 0, g = h ? e.features[r].id : p ? e.id : void 0, u = !!l && "GeometryCollection" === l.type, a = u ? l.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? l.geometries[o] : l)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === t(i, f, c, s, g)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === t(i.geometries[n], f, c, s, g)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === t(null, f, c, s, g)) return !1; f++ } } function geomReduce(e, t, r) { var n = r; return geomEach(e, function (e, o, i, a, l) { n = 0 === o && void 0 === r ? e : t(n, e, o, i, a, l) }), n } function flattenEach(e, t) { geomEach(e, function (e, r, n, o, i) { var a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": if (!1 === t(helpers.feature(e, n, { bbox: o, id: i }), r, 0)) return !1; return }var l; switch (a) { case "MultiPoint": l = "Point"; break; case "MultiLineString": l = "LineString"; break; case "MultiPolygon": l = "Polygon" }for (var u = 0; u < e.coordinates.length; u++) { var c = e.coordinates[u], s = { type: l, coordinates: c }; if (!1 === t(helpers.feature(s, n), r, u)) return !1 } }) } function flattenReduce(e, t, r) { var n = r; return flattenEach(e, function (e, o, i) { n = 0 === o && 0 === i && void 0 === r ? e : t(n, e, o, i) }), n } function segmentEach(e, t) { flattenEach(e, function (e, r, n) { var o = 0; if (e.geometry) { var i = e.geometry.type; if ("Point" !== i && "MultiPoint" !== i) { var a, l = 0, u = 0, c = 0; return !1 !== coordEach(e, function (i, s, g, f, h) { if (void 0 === a || r > l || f > u || h > c) return a = i, l = r, u = f, c = h, void (o = 0); var p = helpers.lineString([a, i], e.properties); if (!1 === t(p, r, n, h, o)) return !1; o++, a = i }) && void 0 } } }) } function segmentReduce(e, t, r) { var n = r, o = !1; return segmentEach(e, function (e, i, a, l, u) { n = !1 === o && void 0 === r ? e : t(n, e, i, a, l, u), o = !0 }), n } function lineEach(e, t) { if (!e) throw new Error("geojson is required"); flattenEach(e, function (e, r, n) { if (null !== e.geometry) { var o = e.geometry.type, i = e.geometry.coordinates; switch (o) { case "LineString": if (!1 === t(e, r, n, 0, 0)) return !1; break; case "Polygon": for (var a = 0; a < i.length; a++)if (!1 === t(helpers.lineString(i[a], e.properties), r, n, a)) return !1 } } }) } function lineReduce(e, t, r) { var n = r; return lineEach(e, function (e, o, i, a) { n = 0 === o && void 0 === r ? e : t(n, e, o, i, a) }), n } function findSegment(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var r, n = t.featureIndex || 0, o = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a = t.segmentIndex || 0, l = t.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), l = l || e.features[n].properties, r = e.features[n].geometry; break; case "Feature": l = l || e.properties, r = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": r = e; break; default: throw new Error("geojson is invalid") }if (null === r) return null; var u = r.coordinates; switch (r.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), helpers.lineString([u[a], u[a + 1]], l, t); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), helpers.lineString([u[i][a], u[i][a + 1]], l, t); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), helpers.lineString([u[o][a], u[o][a + 1]], l, t); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), helpers.lineString([u[o][i][a], u[o][i][a + 1]], l, t) }throw new Error("geojson is invalid") } function findPoint(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var r, n = t.featureIndex || 0, o = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a = t.coordIndex || 0, l = t.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), l = l || e.features[n].properties, r = e.features[n].geometry; break; case "Feature": l = l || e.properties, r = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": r = e; break; default: throw new Error("geojson is invalid") }if (null === r) return null; var u = r.coordinates; switch (r.type) { case "Point": return helpers.point(u, l, t); case "MultiPoint": return o < 0 && (o = u.length + o), helpers.point(u[o], l, t); case "LineString": return a < 0 && (a = u.length + a), helpers.point(u[a], l, t); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), helpers.point(u[i][a], l, t); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), helpers.point(u[o][a], l, t); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), helpers.point(u[o][i][a], l, t) }throw new Error("geojson is invalid") } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.coordEach = coordEach, exports.coordReduce = coordReduce, exports.propEach = propEach, exports.propReduce = propReduce, exports.featureEach = featureEach, exports.featureReduce = featureReduce, exports.coordAll = coordAll, exports.geomEach = geomEach, exports.geomReduce = geomReduce, exports.flattenEach = flattenEach, exports.flattenReduce = flattenReduce, exports.segmentEach = segmentEach, exports.segmentReduce = segmentReduce, exports.lineEach = lineEach, exports.lineReduce = lineReduce, exports.findSegment = findSegment, exports.findPoint = findPoint;

//        }, { "@turf/helpers": 18 }], 21: [function (require, module, exports) {
//            "use strict"; function rhumbDistance(t, a, e) { void 0 === e && (e = {}); var r = invariant_1.getCoord(t), h = invariant_1.getCoord(a); h[0] += h[0] - r[0] > 180 ? -360 : r[0] - h[0] > 180 ? 360 : 0; var n = calculateRhumbDistance(r, h); return helpers_1.convertLength(n, "meters", e.units) } function calculateRhumbDistance(t, a, e) { e = void 0 === e ? helpers_1.earthRadius : Number(e); var r = e, h = t[1] * Math.PI / 180, n = a[1] * Math.PI / 180, i = n - h, u = Math.abs(a[0] - t[0]) * Math.PI / 180; u > Math.PI && (u -= 2 * Math.PI); var s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(h / 2 + Math.PI / 4)), o = Math.abs(s) > 1e-11 ? i / s : Math.cos(h); return Math.sqrt(i * i + o * o * u * u) * r } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers_1 = require("@turf/helpers"), invariant_1 = require("@turf/invariant"); exports.default = rhumbDistance;

//        }, { "@turf/helpers": 18, "@turf/invariant": 19 }], 22: [function (require, module, exports) {
//            "use strict"; function quickselect(t, e, n, i, r) { quickselectStep(t, e, n || 0, i || t.length - 1, r || defaultCompare) } function quickselectStep(t, e, n, i, r) { for (; i > n;) { if (i - n > 600) { var o = i - n + 1, a = e - n + 1, h = Math.log(o), s = .5 * Math.exp(2 * h / 3), l = .5 * Math.sqrt(h * s * (o - s) / o) * (a - o / 2 < 0 ? -1 : 1); quickselectStep(t, e, Math.max(n, Math.floor(e - a * s / o + l)), Math.min(i, Math.floor(e + (o - a) * s / o + l)), r) } var c = t[e], u = n, f = i; for (swap(t, n, e), r(t[i], c) > 0 && swap(t, n, i); u < f;) { for (swap(t, u, f), u++, f--; r(t[u], c) < 0;)u++; for (; r(t[f], c) > 0;)f-- } 0 === r(t[n], c) ? swap(t, n, f) : (f++, swap(t, f, i)), f <= e && (n = f + 1), e <= f && (i = f - 1) } } function swap(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function defaultCompare(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function rbush(t, e) { if (!(this instanceof rbush)) return new rbush(t, e); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear() } function findItem(t, e, n) { if (!n) return e.indexOf(t); for (var i = 0; i < e.length; i++)if (n(t, e[i])) return i; return -1 } function calcBBox(t, e) { distBBox(t, 0, t.children.length, e, t) } function distBBox(t, e, n, i, r) { r || (r = createNode(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0; for (var o, a = e; a < n; a++)o = t.children[a], extend(r, t.leaf ? i(o) : o); return r } function extend(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function compareNodeMinX(t, e) { return t.minX - e.minX } function compareNodeMinY(t, e) { return t.minY - e.minY } function bboxArea(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function bboxMargin(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function enlargedArea(t, e) { return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY)) } function intersectionArea(t, e) { var n = Math.max(t.minX, e.minX), i = Math.max(t.minY, e.minY), r = Math.min(t.maxX, e.maxX), o = Math.min(t.maxY, e.maxY); return Math.max(0, r - n) * Math.max(0, o - i) } function contains(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function intersects(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function createNode(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function multiSelect(t, e, n, i, r) { for (var o, a = [e, n]; a.length;)n = a.pop(), e = a.pop(), n - e <= i || (o = e + Math.ceil((n - e) / i / 2) * i, quickselect(t, o, e, n, r), a.push(e, o, o, n)) } function coordEach(t, e, n) { if (null !== t) { var i, r, o, a, h, s, l, c, u, f, m = 0, x = 0, d = t.type, p = "FeatureCollection" === d, b = "Feature" === d, g = p ? t.features.length : 1; for (i = 0; i < g; i++)for (u = p ? t.features[i].geometry : b ? t.geometry : t, f = !!u && "GeometryCollection" === u.type, l = f ? u.geometries.length : 1, r = 0; r < l; r++) { var B = 0; if (null !== (s = f ? u.geometries[r] : u)) { c = s.coordinates; var M = s.type; switch (m = !n || "Polygon" !== M && "MultiPolygon" !== M ? 0 : 1, M) { case null: break; case "Point": e(c, x, i, B), x++, B++; break; case "LineString": case "MultiPoint": for (o = 0; o < c.length; o++)e(c[o], x, i, B), x++, "MultiPoint" === M && B++; "LineString" === M && B++; break; case "Polygon": case "MultiLineString": for (o = 0; o < c.length; o++) { for (a = 0; a < c[o].length - m; a++)e(c[o][a], x, i, B), x++; "MultiLineString" === M && B++ } "Polygon" === M && B++; break; case "MultiPolygon": for (o = 0; o < c.length; o++) { for (a = 0; a < c[o].length; a++)for (h = 0; h < c[o][a].length - m; h++)e(c[o][a][h], x, i, B), x++; B++ } break; case "GeometryCollection": for (o = 0; o < s.geometries.length; o++)coordEach(s.geometries[o], e, n); break; default: throw new Error("Unknown Geometry Type") } } } } } function featureEach(t, e) { if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length; n++)e(t.features[n], n) } function geojsonRbush(t) { var e = rbush(t); return e.insert = function (t) { if (Array.isArray(t)) { var e = t; t = bboxPolygon(e), t.bbox = e } else t.bbox = t.bbox ? t.bbox : turfBBox(t); return rbush.prototype.insert.call(this, t) }, e.load = function (t) { var e = []; return Array.isArray(t) ? t.forEach(function (t) { var n = bboxPolygon(t); n.bbox = t, e.push(n) }) : featureEach(t, function (t) { t.bbox = t.bbox ? t.bbox : turfBBox(t), e.push(t) }), rbush.prototype.load.call(this, e) }, e.remove = function (t) { if (Array.isArray(t)) { var e = t; t = bboxPolygon(e), t.bbox = e } return rbush.prototype.remove.call(this, t) }, e.clear = function () { return rbush.prototype.clear.call(this) }, e.search = function (t) { return { type: "FeatureCollection", features: rbush.prototype.search.call(this, this.toBBox(t)) } }, e.collides = function (t) { return rbush.prototype.collides.call(this, this.toBBox(t)) }, e.all = function () { return { type: "FeatureCollection", features: rbush.prototype.all.call(this) } }, e.toJSON = function () { return rbush.prototype.toJSON.call(this) }, e.fromJSON = function (t) { return rbush.prototype.fromJSON.call(this, t) }, e.toBBox = function (t) { var e; return e = t.bbox ? t.bbox : Array.isArray(t) && 4 === t.length ? t : turfBBox(t), { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] } }, e } function bboxPolygon(t) { var e = [t[0], t[1]], n = [t[0], t[3]], i = [t[2], t[3]]; return { type: "Feature", bbox: t, properties: {}, geometry: { type: "Polygon", coordinates: [[e, [t[2], t[1]], i, n, e]] } } } function turfBBox(t) { var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return coordEach(t, function (t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) }), e } rbush.prototype = { all: function () { return this._all(this.data, []) }, search: function (t) { var e = this.data, n = [], i = this.toBBox; if (!intersects(t, e)) return n; for (var r, o, a, h, s = []; e;) { for (r = 0, o = e.children.length; r < o; r++)a = e.children[r], h = e.leaf ? i(a) : a, intersects(t, h) && (e.leaf ? n.push(a) : contains(t, h) ? this._all(a, n) : s.push(a)); e = s.pop() } return n }, collides: function (t) { var e = this.data, n = this.toBBox; if (!intersects(t, e)) return !1; for (var i, r, o, a, h = []; e;) { for (i = 0, r = e.children.length; i < r; i++)if (o = e.children[i], a = e.leaf ? n(o) : o, intersects(t, a)) { if (e.leaf || contains(t, a)) return !0; h.push(o) } e = h.pop() } return !1 }, load: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (var e = 0, n = t.length; e < n; e++)this.insert(t[e]); return this } var i = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === i.height) this._splitRoot(this.data, i); else { if (this.data.height < i.height) { var r = this.data; this.data = i, i = r } this._insert(i, this.data.height - i.height - 1, !0) } else this.data = i; return this }, insert: function (t) { return t && this._insert(t, this.data.height - 1), this }, clear: function () { return this.data = createNode([]), this }, remove: function (t, e) { if (!t) return this; for (var n, i, r, o, a = this.data, h = this.toBBox(t), s = [], l = []; a || s.length;) { if (a || (a = s.pop(), i = s[s.length - 1], n = l.pop(), o = !0), a.leaf && -1 !== (r = findItem(t, a.children, e))) return a.children.splice(r, 1), s.push(a), this._condense(s), this; o || a.leaf || !contains(a, h) ? i ? (n++, a = i.children[n], o = !1) : a = null : (s.push(a), l.push(n), n = 0, i = a, a = a.children[0]) } return this }, toBBox: function (t) { return t }, compareMinX: compareNodeMinX, compareMinY: compareNodeMinY, toJSON: function () { return this.data }, fromJSON: function (t) { return this.data = t, this }, _all: function (t, e) { for (var n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, _build: function (t, e, n, i) { var r, o = n - e + 1, a = this._maxEntries; if (o <= a) return r = createNode(t.slice(e, n + 1)), calcBBox(r, this.toBBox), r; i || (i = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, i - 1))), r = createNode([]), r.leaf = !1, r.height = i; var h, s, l, c, u = Math.ceil(o / a), f = u * Math.ceil(Math.sqrt(a)); for (multiSelect(t, e, n, f, this.compareMinX), h = e; h <= n; h += f)for (l = Math.min(h + f - 1, n), multiSelect(t, h, l, u, this.compareMinY), s = h; s <= l; s += u)c = Math.min(s + u - 1, l), r.children.push(this._build(t, s, c, i - 1)); return calcBBox(r, this.toBBox), r }, _chooseSubtree: function (t, e, n, i) { for (var r, o, a, h, s, l, c, u; ;) { if (i.push(e), e.leaf || i.length - 1 === n) break; for (c = u = 1 / 0, r = 0, o = e.children.length; r < o; r++)a = e.children[r], s = bboxArea(a), l = enlargedArea(t, a) - s, l < u ? (u = l, c = s < c ? s : c, h = a) : l === u && s < c && (c = s, h = a); e = h || e.children[0] } return e }, _insert: function (t, e, n) { var i = this.toBBox, r = n ? t : i(t), o = [], a = this._chooseSubtree(r, this.data, e, o); for (a.children.push(t), extend(a, r); e >= 0 && o[e].children.length > this._maxEntries;)this._split(o, e), e--; this._adjustParentBBoxes(r, o, e) }, _split: function (t, e) { var n = t[e], i = n.children.length, r = this._minEntries; this._chooseSplitAxis(n, r, i); var o = this._chooseSplitIndex(n, r, i), a = createNode(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, calcBBox(n, this.toBBox), calcBBox(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, _splitRoot: function (t, e) { this.data = createNode([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, calcBBox(this.data, this.toBBox) }, _chooseSplitIndex: function (t, e, n) { var i, r, o, a, h, s, l, c; for (s = l = 1 / 0, i = e; i <= n - e; i++)r = distBBox(t, 0, i, this.toBBox), o = distBBox(t, i, n, this.toBBox), a = intersectionArea(r, o), h = bboxArea(r) + bboxArea(o), a < s ? (s = a, c = i, l = h < l ? h : l) : a === s && h < l && (l = h, c = i); return c }, _chooseSplitAxis: function (t, e, n) { var i = t.leaf ? this.compareMinX : compareNodeMinX, r = t.leaf ? this.compareMinY : compareNodeMinY; this._allDistMargin(t, e, n, i) < this._allDistMargin(t, e, n, r) && t.children.sort(i) }, _allDistMargin: function (t, e, n, i) { t.children.sort(i); var r, o, a = this.toBBox, h = distBBox(t, 0, e, a), s = distBBox(t, n - e, n, a), l = bboxMargin(h) + bboxMargin(s); for (r = e; r < n - e; r++)o = t.children[r], extend(h, t.leaf ? a(o) : o), l += bboxMargin(h); for (r = n - e - 1; r >= e; r--)o = t.children[r], extend(s, t.leaf ? a(o) : o), l += bboxMargin(s); return l }, _adjustParentBBoxes: function (t, e, n) { for (var i = n; i >= 0; i--)extend(e[i], t) }, _condense: function (t) { for (var e, n = t.length - 1; n >= 0; n--)0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children, e.splice(e.indexOf(t[n]), 1)) : this.clear() : calcBBox(t[n], this.toBBox) }, _initFormat: function (t) { var e = ["return a", " - b", ";"]; this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};") } }, module.exports = geojsonRbush, module.exports.default = geojsonRbush;
//        }, {}], 23: [function (require, module, exports) {
//            module.exports = { lineSlice: require("@turf/line-slice"), lineSliceAlong: require("@turf/line-slice-along"), pointToLineDistance: require("@turf/point-to-line-distance"), along: require("@turf/along"), bearing: require("@turf/bearing"), helpers: require("@turf/helpers"), length: require("@turf/length"), nearestPoint: require("@turf/nearest-point") };
//        }, { "@turf/along": 1, "@turf/bearing": 2, "@turf/helpers": 6, "@turf/length": 8, "@turf/line-slice": 12, "@turf/line-slice-along": 11, "@turf/nearest-point": 15, "@turf/point-to-line-distance": 16 }]
//    }, {}, [23])(23)
//});

(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.turf = f() } })(function () {
    var define, module, exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
        1: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function along(e, r, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var n; if ("Feature" === e.type) n = e.geometry.coordinates; else { if ("LineString" !== e.type) throw new Error("input must be a LineString Feature or Geometry"); n = e.coordinates } if (!helpers.isNumber(r)) throw new Error("distance must be a number"); for (var i = 0, o = 0; o < n.length && !(r >= i && o === n.length - 1); o++) { if (i >= r) { var a = r - i; if (a) { var u = bearing(n[o], n[o - 1]) - 180; return destination(n[o], a, u, t) } return helpers.point(n[o]) } i += measureDistance(n[o], n[o + 1], t) } return helpers.point(n[n.length - 1]) } var bearing = _interopDefault(require("@turf/bearing")), destination = _interopDefault(require("@turf/destination")), measureDistance = _interopDefault(require("@turf/distance")), helpers = require("@turf/helpers"); module.exports = along, module.exports.default = along;

        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6 }], 2: [function (require, module, exports) {
            "use strict"; function bearing(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); if (!0 === a.final) return calculateFinalBearing(e, r); var i = invariant.getCoord(e), n = invariant.getCoord(r), s = helpers.degreesToRadians(i[0]), t = helpers.degreesToRadians(n[0]), o = helpers.degreesToRadians(i[1]), l = helpers.degreesToRadians(n[1]), h = Math.sin(t - s) * Math.cos(l), d = Math.cos(o) * Math.sin(l) - Math.sin(o) * Math.cos(l) * Math.cos(t - s); return helpers.radiansToDegrees(Math.atan2(h, d)) } function calculateFinalBearing(e, r) { var a = bearing(r, e); return a = (a + 180) % 360 } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = bearing, module.exports.default = bearing;

        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 3: [function (require, module, exports) {
            "use strict"; function clone(e) { if (!e) throw new Error("geojson is required"); switch (e.type) { case "Feature": return cloneFeature(e); case "FeatureCollection": return cloneFeatureCollection(e); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return cloneGeometry(e); default: throw new Error("unknown GeoJSON type") } } function cloneFeature(e) { var t = { type: "Feature" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "properties": case "geometry": return; default: t[o] = e[o] } }), t.properties = cloneProperties(e.properties), t.geometry = cloneGeometry(e.geometry), t } function cloneProperties(e) { var t = {}; return e ? (Object.keys(e).forEach(function (o) { var r = e[o]; "object" == typeof r ? null === r ? t[o] = null : r.length ? t[o] = r.map(function (e) { return e }) : t[o] = cloneProperties(r) : t[o] = r }), t) : t } function cloneFeatureCollection(e) { var t = { type: "FeatureCollection" }; return Object.keys(e).forEach(function (o) { switch (o) { case "type": case "features": return; default: t[o] = e[o] } }), t.features = e.features.map(function (e) { return cloneFeature(e) }), t } function cloneGeometry(e) { var t = { type: e.type }; return e.bbox && (t.bbox = e.bbox), "GeometryCollection" === e.type ? (t.geometries = e.geometries.map(function (e) { return cloneGeometry(e) }), t) : (t.coordinates = deepSlice(e.coordinates), t) } function deepSlice(e) { return "object" != typeof e[0] ? e.slice() : e.map(function (e) { return deepSlice(e) }) } module.exports = clone, module.exports.default = clone;

        }, {}], 4: [function (require, module, exports) {
            "use strict"; function destination(e, s, a, r) { if (r = r || {}, !helpers.isObject(r)) throw new Error("options is invalid"); var t = r.units, i = r.properties, n = invariant.getCoord(e), o = helpers.degreesToRadians(n[0]), h = helpers.degreesToRadians(n[1]), d = helpers.degreesToRadians(a), p = helpers.lengthToRadians(s, t), l = Math.asin(Math.sin(h) * Math.cos(p) + Math.cos(h) * Math.sin(p) * Math.cos(d)), M = o + Math.atan2(Math.sin(d) * Math.sin(p) * Math.cos(h), Math.cos(p) - Math.sin(h) * Math.sin(l)), u = helpers.radiansToDegrees(M), c = helpers.radiansToDegrees(l); return helpers.point([u, c], i) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = destination, module.exports.default = destination;

        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 5: [function (require, module, exports) {
            "use strict"; function distance(e, r, a) { if (a = a || {}, !helpers.isObject(a)) throw new Error("options is invalid"); var t = a.units, s = invariant.getCoord(e), i = invariant.getCoord(r), n = helpers.degreesToRadians(i[1] - s[1]), o = helpers.degreesToRadians(i[0] - s[0]), h = helpers.degreesToRadians(s[1]), d = helpers.degreesToRadians(i[1]), p = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(h) * Math.cos(d); return helpers.radiansToLength(2 * Math.atan2(Math.sqrt(p), Math.sqrt(1 - p)), t) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"); module.exports = distance, module.exports.default = distance;

        }, { "@turf/helpers": 6, "@turf/invariant": 7 }], 6: [function (require, module, exports) {
            "use strict"; function feature(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox, i = t.id; if (void 0 === r) throw new Error("geometry is required"); if (e && e.constructor !== Object) throw new Error("properties must be an Object"); o && validateBBox(o), i && validateId(i); var n = { type: "Feature" }; return i && (n.id = i), o && (n.bbox = o), n.properties = e || {}, n.geometry = r, n } function geometry(r, e, t) { if (t = t || {}, !isObject(t)) throw new Error("options is invalid"); var o = t.bbox; if (!r) throw new Error("type is required"); if (!e) throw new Error("coordinates is required"); if (!Array.isArray(e)) throw new Error("coordinates must be an Array"); o && validateBBox(o); var i; switch (r) { case "Point": i = point(e).geometry; break; case "LineString": i = lineString(e).geometry; break; case "Polygon": i = polygon(e).geometry; break; case "MultiPoint": i = multiPoint(e).geometry; break; case "MultiLineString": i = multiLineString(e).geometry; break; case "MultiPolygon": i = multiPolygon(e).geometry; break; default: throw new Error(r + " is invalid") }return o && (i.bbox = o), i } function point(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); if (r.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!isNumber(r[0]) || !isNumber(r[1])) throw new Error("coordinates must contain numbers"); return feature({ type: "Point", coordinates: r }, e, t) } function points(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return point(r, e) }), t) } function polygon(r, e, t) { if (!r) throw new Error("coordinates is required"); for (var o = 0; o < r.length; o++) { var i = r[o]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var n = 0; n < i[i.length - 1].length; n++) { if (0 === o && 0 === n && !isNumber(i[0][0]) || !isNumber(i[0][1])) throw new Error("coordinates must contain numbers"); if (i[i.length - 1][n] !== i[0][n]) throw new Error("First and last Position are not equivalent.") } } return feature({ type: "Polygon", coordinates: r }, e, t) } function polygons(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return polygon(r, e) }), t) } function lineString(r, e, t) { if (!r) throw new Error("coordinates is required"); if (r.length < 2) throw new Error("coordinates must be an array of two or more positions"); if (!isNumber(r[0][1]) || !isNumber(r[0][1])) throw new Error("coordinates must contain numbers"); return feature({ type: "LineString", coordinates: r }, e, t) } function lineStrings(r, e, t) { if (!r) throw new Error("coordinates is required"); if (!Array.isArray(r)) throw new Error("coordinates must be an Array"); return featureCollection(r.map(function (r) { return lineString(r, e) }), t) } function featureCollection(r, e) { if (e = e || {}, !isObject(e)) throw new Error("options is invalid"); var t = e.bbox, o = e.id; if (!r) throw new Error("No features passed"); if (!Array.isArray(r)) throw new Error("features must be an Array"); t && validateBBox(t), o && validateId(o); var i = { type: "FeatureCollection" }; return o && (i.id = o), t && (i.bbox = t), i.features = r, i } function multiLineString(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiLineString", coordinates: r }, e, t) } function multiPoint(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPoint", coordinates: r }, e, t) } function multiPolygon(r, e, t) { if (!r) throw new Error("coordinates is required"); return feature({ type: "MultiPolygon", coordinates: r }, e, t) } function geometryCollection(r, e, t) { if (!r) throw new Error("geometries is required"); if (!Array.isArray(r)) throw new Error("geometries must be an Array"); return feature({ type: "GeometryCollection", geometries: r }, e, t) } function round(r, e) { if (void 0 === r || null === r || isNaN(r)) throw new Error("num is required"); if (e && !(e >= 0)) throw new Error("precision must be a positive number"); var t = Math.pow(10, e || 0); return Math.round(r * t) / t } function radiansToLength(r, e) { if (void 0 === r || null === r) throw new Error("radians is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r * t } function lengthToRadians(r, e) { if (void 0 === r || null === r) throw new Error("distance is required"); if (e && "string" != typeof e) throw new Error("units must be a string"); var t = factors[e || "kilometers"]; if (!t) throw new Error(e + " units is invalid"); return r / t } function lengthToDegrees(r, e) { return radiansToDegrees(lengthToRadians(r, e)) } function bearingToAzimuth(r) { if (null === r || void 0 === r) throw new Error("bearing is required"); var e = r % 360; return e < 0 && (e += 360), e } function radiansToDegrees(r) { if (null === r || void 0 === r) throw new Error("radians is required"); return r % (2 * Math.PI) * 180 / Math.PI } function degreesToRadians(r) { if (null === r || void 0 === r) throw new Error("degrees is required"); return r % 360 * Math.PI / 180 } function convertLength(r, e, t) { if (null === r || void 0 === r) throw new Error("length is required"); if (!(r >= 0)) throw new Error("length must be a positive number"); return radiansToLength(lengthToRadians(r, e), t || "kilometers") } function convertArea(r, e, t) { if (null === r || void 0 === r) throw new Error("area is required"); if (!(r >= 0)) throw new Error("area must be a positive number"); var o = areaFactors[e || "meters"]; if (!o) throw new Error("invalid original units"); var i = areaFactors[t || "kilometers"]; if (!i) throw new Error("invalid final units"); return r / o * i } function isNumber(r) { return !isNaN(r) && null !== r && !Array.isArray(r) } function isObject(r) { return !!r && r.constructor === Object } function validateBBox(r) { if (!r) throw new Error("bbox is required"); if (!Array.isArray(r)) throw new Error("bbox must be an Array"); if (4 !== r.length && 6 !== r.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); r.forEach(function (r) { if (!isNumber(r)) throw new Error("bbox must only contain numbers") }) } function validateId(r) { if (!r) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof r)) throw new Error("id must be a number or a string") } function radians2degrees() { throw new Error("method has been renamed to `radiansToDegrees`") } function degrees2radians() { throw new Error("method has been renamed to `degreesToRadians`") } function distanceToDegrees() { throw new Error("method has been renamed to `lengthToDegrees`") } function distanceToRadians() { throw new Error("method has been renamed to `lengthToRadians`") } function radiansToDistance() { throw new Error("method has been renamed to `radiansToLength`") } function bearingToAngle() { throw new Error("method has been renamed to `bearingToAzimuth`") } function convertDistance() { throw new Error("method has been renamed to `convertLength`") } Object.defineProperty(exports, "__esModule", { value: !0 }); var earthRadius = 6371008.8, factors = { meters: earthRadius, metres: earthRadius, millimeters: 1e3 * earthRadius, millimetres: 1e3 * earthRadius, centimeters: 100 * earthRadius, centimetres: 100 * earthRadius, kilometers: earthRadius / 1e3, kilometres: earthRadius / 1e3, miles: earthRadius / 1609.344, nauticalmiles: earthRadius / 1852, inches: 39.37 * earthRadius, yards: earthRadius / 1.0936, feet: 3.28084 * earthRadius, radians: 1, degrees: earthRadius / 111325 }, unitsFactors = { meters: 1, metres: 1, millimeters: 1e3, millimetres: 1e3, centimeters: 100, centimetres: 100, kilometers: .001, kilometres: .001, miles: 1 / 1609.344, nauticalmiles: 1 / 1852, inches: 39.37, yards: 1 / 1.0936, feet: 3.28084, radians: 1 / earthRadius, degrees: 1 / 111325 }, areaFactors = { meters: 1, metres: 1, millimeters: 1e6, millimetres: 1e6, centimeters: 1e4, centimetres: 1e4, kilometers: 1e-6, kilometres: 1e-6, acres: 247105e-9, miles: 3.86e-7, yards: 1.195990046, feet: 10.763910417, inches: 1550.003100006 }; exports.earthRadius = earthRadius, exports.factors = factors, exports.unitsFactors = unitsFactors, exports.areaFactors = areaFactors, exports.feature = feature, exports.geometry = geometry, exports.point = point, exports.points = points, exports.polygon = polygon, exports.polygons = polygons, exports.lineString = lineString, exports.lineStrings = lineStrings, exports.featureCollection = featureCollection, exports.multiLineString = multiLineString, exports.multiPoint = multiPoint, exports.multiPolygon = multiPolygon, exports.geometryCollection = geometryCollection, exports.round = round, exports.radiansToLength = radiansToLength, exports.lengthToRadians = lengthToRadians, exports.lengthToDegrees = lengthToDegrees, exports.bearingToAzimuth = bearingToAzimuth, exports.radiansToDegrees = radiansToDegrees, exports.degreesToRadians = degreesToRadians, exports.convertLength = convertLength, exports.convertArea = convertArea, exports.isNumber = isNumber, exports.isObject = isObject, exports.validateBBox = validateBBox, exports.validateId = validateId, exports.radians2degrees = radians2degrees, exports.degrees2radians = degrees2radians, exports.distanceToDegrees = distanceToDegrees, exports.distanceToRadians = distanceToRadians, exports.radiansToDistance = radiansToDistance, exports.bearingToAngle = bearingToAngle, exports.convertDistance = convertDistance;

        }, {}], 7: [function (require, module, exports) {
            "use strict"; function getCoord(e) { if (!e) throw new Error("obj is required"); var r = getCoords(e); if (r.length > 1 && helpers.isNumber(r[0]) && helpers.isNumber(r[1])) return r; throw new Error("Coordinate is not a valid Point") } function getCoords(e) { if (!e) throw new Error("obj is required"); var r; if (e.length ? r = e : e.coordinates ? r = e.coordinates : e.geometry && e.geometry.coordinates && (r = e.geometry.coordinates), r) return containsNumber(r), r; throw new Error("No valid coordinates") } function containsNumber(e) { if (e.length > 1 && helpers.isNumber(e[0]) && helpers.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return containsNumber(e[0]); throw new Error("coordinates must only contain numbers") } function geojsonType(e, r, o) { if (!r || !o) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.type) } function featureOf(e, r, o) { if (!e) throw new Error("No feature passed"); if (!o) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + e.geometry.type) } function collectionOf(e, r, o) { if (!e) throw new Error("No featureCollection passed"); if (!o) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + o + ", FeatureCollection required"); for (var t = 0; t < e.features.length; t++) { var n = e.features[t]; if (!n || "Feature" !== n.type || !n.geometry) throw new Error("Invalid input to " + o + ", Feature with geometry required"); if (!n.geometry || n.geometry.type !== r) throw new Error("Invalid input to " + o + ": must be a " + r + ", given " + n.geometry.type) } } function getGeom(e) { if (!e) throw new Error("geojson is required"); if (void 0 !== e.geometry) return e.geometry; if (e.coordinates || e.geometries) return e; throw new Error("geojson must be a valid Feature or Geometry Object") } function getGeomType() { throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType") } function getType(e, r) { if (!e) throw new Error((r || "geojson") + " is required"); if (e.geometry && e.geometry.type) return e.geometry.type; if (e.type) return e.type; throw new Error((r || "geojson") + " is invalid") } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.getCoord = getCoord, exports.getCoords = getCoords, exports.containsNumber = containsNumber, exports.geojsonType = geojsonType, exports.featureOf = featureOf, exports.collectionOf = collectionOf, exports.getGeom = getGeom, exports.getGeomType = getGeomType, exports.getType = getType;
        }, { "@turf/helpers": 6 }], 8: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function length(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); if (!e) throw new Error("geojson is required"); return meta.segmentReduce(e, function (e, r) { var n = r.geometry.coordinates; return e + distance(n[0], n[1], t) }, 0) } var distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"), helpers = require("@turf/helpers"); module.exports = length, module.exports.default = length;

        }, { "@turf/distance": 5, "@turf/helpers": 6, "@turf/meta": 13 }], 9: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineIntersect(e, t) { var r = {}, n = []; if ("LineString" === e.type && (e = helpers.feature(e)), "LineString" === t.type && (t = helpers.feature(t)), "Feature" === e.type && "Feature" === t.type && "LineString" === e.geometry.type && "LineString" === t.geometry.type && 2 === e.geometry.coordinates.length && 2 === t.geometry.coordinates.length) { var i = intersects(e, t); return i && n.push(i), helpers.featureCollection(n) } var o = rbush(); return o.load(lineSegment(t)), meta.featureEach(lineSegment(e), function (e) { meta.featureEach(o.search(e), function (t) { var i = intersects(e, t); if (i) { var o = invariant.getCoords(i).join(","); r[o] || (r[o] = !0, n.push(i)) } }) }), helpers.featureCollection(n) } function intersects(e, t) { var r = invariant.getCoords(e), n = invariant.getCoords(t); if (2 !== r.length) throw new Error("<intersects> line1 must only contain 2 coordinates"); if (2 !== n.length) throw new Error("<intersects> line2 must only contain 2 coordinates"); var i = r[0][0], o = r[0][1], a = r[1][0], u = r[1][1], s = n[0][0], l = n[0][1], f = n[1][0], c = n[1][1], p = (c - l) * (a - i) - (f - s) * (u - o), h = (f - s) * (o - l) - (c - l) * (i - s), g = (a - i) * (o - l) - (u - o) * (i - s); if (0 === p) return null; var m = h / p, v = g / p; if (m >= 0 && m <= 1 && v >= 0 && v <= 1) { var d = i + m * (a - i), y = o + m * (u - o); return helpers.point([d, y]) } return null } var rbush = _interopDefault(require("geojson-rbush")), lineSegment = _interopDefault(require("@turf/line-segment")), invariant = require("@turf/invariant"), meta = require("@turf/meta"), helpers = require("@turf/helpers"); module.exports = lineIntersect, module.exports.default = lineIntersect;
        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/line-segment": 10, "@turf/meta": 13, "geojson-rbush": 22 }], 10: [function (require, module, exports) {
            "use strict"; function lineSegment(e) { if (!e) throw new Error("geojson is required"); var r = []; return meta.flattenEach(e, function (e) { lineSegmentFeature(e, r) }), helpers.featureCollection(r) } function lineSegmentFeature(e, r) { var t = [], n = e.geometry; switch (n.type) { case "Polygon": t = invariant.getCoords(n); break; case "LineString": t = [invariant.getCoords(n)] }t.forEach(function (t) { createSegments(t, e.properties).forEach(function (e) { e.id = r.length, r.push(e) }) }) } function createSegments(e, r) { var t = []; return e.reduce(function (e, n) { var i = helpers.lineString([e, n], r); return i.bbox = bbox(e, n), t.push(i), n }), t } function bbox(e, r) { var t = e[0], n = e[1], i = r[0], o = r[1]; return [t < i ? t : i, n < o ? n : o, t > i ? t : i, n > o ? n : o] } var helpers = require("@turf/helpers"), invariant = require("@turf/invariant"), meta = require("@turf/meta"); module.exports = lineSegment, module.exports.default = lineSegment;
        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/meta": 13 }], 11: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineSliceAlong(e, r, t, i) { if (i = i || {}, !helpers.isObject(i)) throw new Error("options is invalid"); var n, o = []; if ("Feature" === e.type) n = e.geometry.coordinates; else { if ("LineString" !== e.type) throw new Error("input must be a LineString Feature or Geometry"); n = e.coordinates } for (var l, u, s, a = 0, p = 0; p < n.length && !(r >= a && p === n.length - 1); p++) { if (a > r && 0 === o.length) { if (!(l = r - a)) return o.push(n[p]), helpers.lineString(o); u = bearing(n[p], n[p - 1]) - 180, s = destination(n[p], l, u, i), o.push(s.geometry.coordinates) } if (a >= t) return (l = t - a) ? (u = bearing(n[p], n[p - 1]) - 180, s = destination(n[p], l, u, i), o.push(s.geometry.coordinates), helpers.lineString(o)) : (o.push(n[p]), helpers.lineString(o)); if (a >= r && o.push(n[p]), p === n.length - 1) return helpers.lineString(o); a += distance(n[p], n[p + 1], i) } return helpers.lineString(n[n.length - 1]) } var bearing = _interopDefault(require("@turf/bearing")), distance = _interopDefault(require("@turf/distance")), destination = _interopDefault(require("@turf/destination")), helpers = require("@turf/helpers"); module.exports = lineSliceAlong, module.exports.default = lineSliceAlong;

        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6 }], 12: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function lineSlice(e, r, i) { var n = invariant.getCoords(i); if ("LineString" !== invariant.getType(i)) throw new Error("line must be a LineString"); var t, o = nearestPointOnLine(i, e), a = nearestPointOnLine(i, r); t = o.properties.index <= a.properties.index ? [o, a] : [a, o]; for (var p = [t[0].geometry.coordinates], s = t[0].properties.index + 1; s < t[1].properties.index + 1; s++)p.push(n[s]); return p.push(t[1].geometry.coordinates), helpers.lineString(p, i.properties) } var invariant = require("@turf/invariant"), helpers = require("@turf/helpers"), nearestPointOnLine = _interopDefault(require("@turf/nearest-point-on-line")); module.exports = lineSlice, module.exports.default = lineSlice;
        }, { "@turf/helpers": 6, "@turf/invariant": 7, "@turf/nearest-point-on-line": 14 }], 13: [function (require, module, exports) {
            "use strict"; function coordEach(e, t, o) { if (null !== e) for (var r, n, c, i, a, u, l, s, f = 0, g = 0, p = e.type, h = "FeatureCollection" === p, d = "Feature" === p, y = h ? e.features.length : 1, m = 0; m < y; m++) { l = h ? e.features[m].geometry : d ? e.geometry : e, s = !!l && "GeometryCollection" === l.type, a = s ? l.geometries.length : 1; for (var E = 0; E < a; E++) { var v = 0, P = 0; if (null !== (i = s ? l.geometries[E] : l)) { u = i.coordinates; var R = i.type; switch (f = !o || "Polygon" !== R && "MultiPolygon" !== R ? 0 : 1, R) { case null: break; case "Point": t(u, g, m, v, P), g++, v++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++)t(u[r], g, m, v, P), g++, "MultiPoint" === R && v++; "LineString" === R && v++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (n = 0; n < u[r].length - f; n++)t(u[r][n], g, m, v, P), g++; "MultiLineString" === R && v++, "Polygon" === R && P++ } "Polygon" === R && v++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for ("MultiPolygon" === R && (P = 0), n = 0; n < u[r].length; n++) { for (c = 0; c < u[r][n].length - f; c++)t(u[r][n][c], g, m, v, P), g++; P++ } v++ } break; case "GeometryCollection": for (r = 0; r < i.geometries.length; r++)coordEach(i.geometries[r], t, o); break; default: throw new Error("Unknown Geometry Type") } } } } } function coordReduce(e, t, o, r) { var n = o; return coordEach(e, function (e, r, c, i, a) { n = 0 === r && void 0 === o ? e : t(n, e, r, c, i, a) }, r), n } function propEach(e, t) { var o; switch (e.type) { case "FeatureCollection": for (o = 0; o < e.features.length; o++)t(e.features[o].properties, o); break; case "Feature": t(e.properties, 0) } } function propReduce(e, t, o) { var r = o; return propEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function featureEach(e, t) { if ("Feature" === e.type) t(e, 0); else if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++)t(e.features[o], o) } function featureReduce(e, t, o) { var r = o; return featureEach(e, function (e, n) { r = 0 === n && void 0 === o ? e : t(r, e, n) }), r } function coordAll(e) { var t = []; return coordEach(e, function (e) { t.push(e) }), t } function geomEach(e, t) { var o, r, n, c, i, a, u, l, s, f, g = 0, p = "FeatureCollection" === e.type, h = "Feature" === e.type, d = p ? e.features.length : 1; for (o = 0; o < d; o++) { for (a = p ? e.features[o].geometry : h ? e.geometry : e, l = p ? e.features[o].properties : h ? e.properties : {}, s = p ? e.features[o].bbox : h ? e.bbox : void 0, f = p ? e.features[o].id : h ? e.id : void 0, u = !!a && "GeometryCollection" === a.type, i = u ? a.geometries.length : 1, n = 0; n < i; n++)if (null !== (c = u ? a.geometries[n] : a)) switch (c.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": t(c, g, l, s, f); break; case "GeometryCollection": for (r = 0; r < c.geometries.length; r++)t(c.geometries[r], g, l, s, f); break; default: throw new Error("Unknown Geometry Type") } else t(null, g, l, s, f); g++ } } function geomReduce(e, t, o) { var r = o; return geomEach(e, function (e, n, c, i, a) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i, a) }), r } function flattenEach(e, t) { geomEach(e, function (e, o, r, n, c) { var i = null === e ? null : e.type; switch (i) { case null: case "Point": case "LineString": case "Polygon": return void t(helpers.feature(e, r, { bbox: n, id: c }), o, 0) }var a; switch (i) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }e.coordinates.forEach(function (e, n) { var c = { type: a, coordinates: e }; t(helpers.feature(c, r), o, n) }) }) } function flattenReduce(e, t, o) { var r = o; return flattenEach(e, function (e, n, c) { r = 0 === n && 0 === c && void 0 === o ? e : t(r, e, n, c) }), r } function segmentEach(e, t) { flattenEach(e, function (e, o, r) { var n = 0; if (e.geometry) { var c = e.geometry.type; "Point" !== c && "MultiPoint" !== c && coordReduce(e, function (c, i, a, u, l, s) { var f = helpers.lineString([c, i], e.properties); return t(f, o, r, s, n), n++, i }) } }) } function segmentReduce(e, t, o) { var r = o, n = !1; return segmentEach(e, function (e, c, i, a, u) { r = !1 === n && void 0 === o ? e : t(r, e, c, i, a, u), n = !0 }), r } function lineEach(e, t) { if (!e) throw new Error("geojson is required"); flattenEach(e, function (e, o, r) { if (null !== e.geometry) { var n = e.geometry.type, c = e.geometry.coordinates; switch (n) { case "LineString": t(e, o, r, 0, 0); break; case "Polygon": for (var i = 0; i < c.length; i++)t(helpers.lineString(c[i], e.properties), o, r, i) } } }) } function lineReduce(e, t, o) { var r = o; return lineEach(e, function (e, n, c, i) { r = 0 === n && void 0 === o ? e : t(r, e, n, c, i) }), r } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.coordEach = coordEach, exports.coordReduce = coordReduce, exports.propEach = propEach, exports.propReduce = propReduce, exports.featureEach = featureEach, exports.featureReduce = featureReduce, exports.coordAll = coordAll, exports.geomEach = geomEach, exports.geomReduce = geomReduce, exports.flattenEach = flattenEach, exports.flattenReduce = flattenReduce, exports.segmentEach = segmentEach, exports.segmentReduce = segmentReduce, exports.lineEach = lineEach, exports.lineReduce = lineReduce;

        }, { "@turf/helpers": 6 }], 14: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function nearestPointOnLine(e, t, r) { if (r = r || {}, !helpers.isObject(r)) throw new Error("options is invalid"); var i = e.geometry ? e.geometry.type : e.type; if ("LineString" !== i && "MultiLineString" !== i) throw new Error("lines must be LineString or MultiLineString"); var n = helpers.point([1 / 0, 1 / 0], { dist: 1 / 0 }), s = 0; return meta.flattenEach(e, function (e) { for (var i = invariant.getCoords(e), o = 0; o < i.length - 1; o++) { var p = helpers.point(i[o]); p.properties.dist = distance(t, p, r); var a = helpers.point(i[o + 1]); a.properties.dist = distance(t, a, r); var d = distance(p, a, r), u = Math.max(p.properties.dist, a.properties.dist), l = bearing(p, a), f = destination(t, u, l + 90, r), c = destination(t, u, l - 90, r), g = lineIntersects(helpers.lineString([f.geometry.coordinates, c.geometry.coordinates]), helpers.lineString([p.geometry.coordinates, a.geometry.coordinates])), h = null; g.features.length > 0 && (h = g.features[0], h.properties.dist = distance(t, h, r), h.properties.location = s + distance(p, h, r)), p.properties.dist < n.properties.dist && (n = p, n.properties.index = o, n.properties.location = s), a.properties.dist < n.properties.dist && (n = a, n.properties.index = o + 1, n.properties.location = s + d), h && h.properties.dist < n.properties.dist && (n = h, n.properties.index = o), s += d } }), n } var bearing = _interopDefault(require("@turf/bearing")), distance = _interopDefault(require("@turf/distance")), destination = _interopDefault(require("@turf/destination")), lineIntersects = _interopDefault(require("@turf/line-intersect")), meta = require("@turf/meta"), helpers = require("@turf/helpers"), invariant = require("@turf/invariant"); module.exports = nearestPointOnLine, module.exports.default = nearestPointOnLine;

        }, { "@turf/bearing": 2, "@turf/destination": 4, "@turf/distance": 5, "@turf/helpers": 6, "@turf/invariant": 7, "@turf/line-intersect": 9, "@turf/meta": 13 }], 15: [function (require, module, exports) {
            "use strict"; function _interopDefault(e) { return e && "object" == typeof e && "default" in e ? e.default : e } function nearestPoint(e, t) { if (!e) throw new Error("targetPoint is required"); if (!t) throw new Error("points is required"); var r, n = 1 / 0; return meta.featureEach(t, function (t, i) { var o = distance(e, t); o < n && (r = clone(t), r.properties.featureIndex = i, r.properties.distanceToPoint = o, n = o) }), r } var clone = _interopDefault(require("@turf/clone")), distance = _interopDefault(require("@turf/distance")), meta = require("@turf/meta"); module.exports = nearestPoint, module.exports.default = nearestPoint;

        }, { "@turf/clone": 3, "@turf/distance": 5, "@turf/meta": 13 }], 16: [function (require, module, exports) {
            "use strict"; function pointToLineDistance(e, t, r) { if (void 0 === r && (r = {}), r.method || (r.method = "geodesic"), r.units || (r.units = "kilometers"), !e) throw new Error("pt is required"); if (Array.isArray(e) ? e = helpers_1.point(e) : "Point" === e.type ? e = helpers_1.feature(e) : invariant_1.featureOf(e, "Point", "point"), !t) throw new Error("line is required"); Array.isArray(t) ? t = helpers_1.lineString(t) : "LineString" === t.type ? t = helpers_1.feature(t) : invariant_1.featureOf(t, "LineString", "line"); var i = 1 / 0, n = e.geometry.coordinates; return meta_1.segmentEach(t, function (e) { var t = e.geometry.coordinates[0], a = e.geometry.coordinates[1], o = distanceToSegment(n, t, a, r); o < i && (i = o) }), helpers_1.convertLength(i, "degrees", r.units) } function distanceToSegment(e, t, r, i) { var n = [r[0] - t[0], r[1] - t[1]], a = [e[0] - t[0], e[1] - t[1]], o = dot(a, n); if (o <= 0) return calcDistance(e, t, { method: i.method, units: "degrees" }); var s = dot(n, n); if (s <= o) return calcDistance(e, r, { method: i.method, units: "degrees" }); var u = o / s; return calcDistance(e, [t[0] + u * n[0], t[1] + u * n[1]], { method: i.method, units: "degrees" }) } function dot(e, t) { return e[0] * t[0] + e[1] * t[1] } function calcDistance(e, t, r) { return "planar" === r.method ? rhumb_distance_1.default(e, t, r) : distance_1.default(e, t, r) } Object.defineProperty(exports, "__esModule", { value: !0 }); var invariant_1 = require("@turf/invariant"), meta_1 = require("@turf/meta"), distance_1 = require("@turf/distance"), rhumb_distance_1 = require("@turf/rhumb-distance"), helpers_1 = require("@turf/helpers"); exports.default = pointToLineDistance;

        }, { "@turf/distance": 17, "@turf/helpers": 18, "@turf/invariant": 19, "@turf/meta": 20, "@turf/rhumb-distance": 21 }], 17: [function (require, module, exports) {
            "use strict"; function distance(e, a, r) { void 0 === r && (r = {}); var t = invariant_1.getCoord(e), s = invariant_1.getCoord(a), i = helpers_1.degreesToRadians(s[1] - t[1]), n = helpers_1.degreesToRadians(s[0] - t[0]), o = helpers_1.degreesToRadians(t[1]), d = helpers_1.degreesToRadians(s[1]), h = Math.pow(Math.sin(i / 2), 2) + Math.pow(Math.sin(n / 2), 2) * Math.cos(o) * Math.cos(d); return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), r.units) } Object.defineProperty(exports, "__esModule", { value: !0 }); var invariant_1 = require("@turf/invariant"), helpers_1 = require("@turf/helpers"); exports.default = distance;

        }, { "@turf/helpers": 18, "@turf/invariant": 19 }], 18: [function (require, module, exports) {
            "use strict"; function feature(e, r, t) { void 0 === t && (t = {}); var o = { type: "Feature" }; return (0 === t.id || t.id) && (o.id = t.id), t.bbox && (o.bbox = t.bbox), o.properties = r || {}, o.geometry = e, o } function geometry(e, r, t) { switch (void 0 === t && (t = {}), e) { case "Point": return point(r).geometry; case "LineString": return lineString(r).geometry; case "Polygon": return polygon(r).geometry; case "MultiPoint": return multiPoint(r).geometry; case "MultiLineString": return multiLineString(r).geometry; case "MultiPolygon": return multiPolygon(r).geometry; default: throw new Error(e + " is invalid") } } function point(e, r, t) { return void 0 === t && (t = {}), feature({ type: "Point", coordinates: e }, r, t) } function points(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return point(e, r) }), t) } function polygon(e, r, t) { void 0 === t && (t = {}); for (var o = 0, n = e; o < n.length; o++) { var i = n[o]; if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); for (var s = 0; s < i[i.length - 1].length; s++)if (i[i.length - 1][s] !== i[0][s]) throw new Error("First and last Position are not equivalent.") } return feature({ type: "Polygon", coordinates: e }, r, t) } function polygons(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return polygon(e, r) }), t) } function lineString(e, r, t) { if (void 0 === t && (t = {}), e.length < 2) throw new Error("coordinates must be an array of two or more positions"); return feature({ type: "LineString", coordinates: e }, r, t) } function lineStrings(e, r, t) { return void 0 === t && (t = {}), featureCollection(e.map(function (e) { return lineString(e, r) }), t) } function featureCollection(e, r) { void 0 === r && (r = {}); var t = { type: "FeatureCollection" }; return r.id && (t.id = r.id), r.bbox && (t.bbox = r.bbox), t.features = e, t } function multiLineString(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiLineString", coordinates: e }, r, t) } function multiPoint(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiPoint", coordinates: e }, r, t) } function multiPolygon(e, r, t) { return void 0 === t && (t = {}), feature({ type: "MultiPolygon", coordinates: e }, r, t) } function geometryCollection(e, r, t) { return void 0 === t && (t = {}), feature({ type: "GeometryCollection", geometries: e }, r, t) } function round(e, r) { if (void 0 === r && (r = 0), r && !(r >= 0)) throw new Error("precision must be a positive number"); var t = Math.pow(10, r || 0); return Math.round(e * t) / t } function radiansToLength(e, r) { void 0 === r && (r = "kilometers"); var t = exports.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e * t } function lengthToRadians(e, r) { void 0 === r && (r = "kilometers"); var t = exports.factors[r]; if (!t) throw new Error(r + " units is invalid"); return e / t } function lengthToDegrees(e, r) { return radiansToDegrees(lengthToRadians(e, r)) } function bearingToAzimuth(e) { var r = e % 360; return r < 0 && (r += 360), r } function radiansToDegrees(e) { return e % (2 * Math.PI) * 180 / Math.PI } function degreesToRadians(e) { return e % 360 * Math.PI / 180 } function convertLength(e, r, t) { if (void 0 === r && (r = "kilometers"), void 0 === t && (t = "kilometers"), !(e >= 0)) throw new Error("length must be a positive number"); return radiansToLength(lengthToRadians(e, r), t) } function convertArea(e, r, t) { if (void 0 === r && (r = "meters"), void 0 === t && (t = "kilometers"), !(e >= 0)) throw new Error("area must be a positive number"); var o = exports.areaFactors[r]; if (!o) throw new Error("invalid original units"); var n = exports.areaFactors[t]; if (!n) throw new Error("invalid final units"); return e / o * n } function isNumber(e) { return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e) } function isObject(e) { return !!e && e.constructor === Object } function validateBBox(e) { if (!e) throw new Error("bbox is required"); if (!Array.isArray(e)) throw new Error("bbox must be an Array"); if (4 !== e.length && 6 !== e.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); e.forEach(function (e) { if (!isNumber(e)) throw new Error("bbox must only contain numbers") }) } function validateId(e) { if (!e) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(typeof e)) throw new Error("id must be a number or a string") } function radians2degrees() { throw new Error("method has been renamed to `radiansToDegrees`") } function degrees2radians() { throw new Error("method has been renamed to `degreesToRadians`") } function distanceToDegrees() { throw new Error("method has been renamed to `lengthToDegrees`") } function distanceToRadians() { throw new Error("method has been renamed to `lengthToRadians`") } function radiansToDistance() { throw new Error("method has been renamed to `radiansToLength`") } function bearingToAngle() { throw new Error("method has been renamed to `bearingToAzimuth`") } function convertDistance() { throw new Error("method has been renamed to `convertLength`") } Object.defineProperty(exports, "__esModule", { value: !0 }), exports.earthRadius = 6371008.8, exports.factors = { centimeters: 100 * exports.earthRadius, centimetres: 100 * exports.earthRadius, degrees: exports.earthRadius / 111325, feet: 3.28084 * exports.earthRadius, inches: 39.37 * exports.earthRadius, kilometers: exports.earthRadius / 1e3, kilometres: exports.earthRadius / 1e3, meters: exports.earthRadius, metres: exports.earthRadius, miles: exports.earthRadius / 1609.344, millimeters: 1e3 * exports.earthRadius, millimetres: 1e3 * exports.earthRadius, nauticalmiles: exports.earthRadius / 1852, radians: 1, yards: exports.earthRadius / 1.0936 }, exports.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: .001, kilometres: .001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / exports.earthRadius, yards: 1 / 1.0936 }, exports.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 3.86e-7, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, exports.feature = feature, exports.geometry = geometry, exports.point = point, exports.points = points, exports.polygon = polygon, exports.polygons = polygons, exports.lineString = lineString, exports.lineStrings = lineStrings, exports.featureCollection = featureCollection, exports.multiLineString = multiLineString, exports.multiPoint = multiPoint, exports.multiPolygon = multiPolygon, exports.geometryCollection = geometryCollection, exports.round = round, exports.radiansToLength = radiansToLength, exports.lengthToRadians = lengthToRadians, exports.lengthToDegrees = lengthToDegrees, exports.bearingToAzimuth = bearingToAzimuth, exports.radiansToDegrees = radiansToDegrees, exports.degreesToRadians = degreesToRadians, exports.convertLength = convertLength, exports.convertArea = convertArea, exports.isNumber = isNumber, exports.isObject = isObject, exports.validateBBox = validateBBox, exports.validateId = validateId, exports.radians2degrees = radians2degrees, exports.degrees2radians = degrees2radians, exports.distanceToDegrees = distanceToDegrees, exports.distanceToRadians = distanceToRadians, exports.radiansToDistance = radiansToDistance, exports.bearingToAngle = bearingToAngle, exports.convertDistance = convertDistance;

        }, {}], 19: [function (require, module, exports) {
            "use strict"; function getCoord(e) { if (!e) throw new Error("coord is required"); if (!Array.isArray(e)) { if ("Feature" === e.type && null !== e.geometry && "Point" === e.geometry.type) return e.geometry.coordinates; if ("Point" === e.type) return e.coordinates } if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e; throw new Error("coord must be GeoJSON Point or an Array of numbers") } function getCoords(e) { if (Array.isArray(e)) return e; if ("Feature" === e.type) { if (null !== e.geometry) return e.geometry.coordinates } else if (e.coordinates) return e.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") } function containsNumber(e) { if (e.length > 1 && helpers_1.isNumber(e[0]) && helpers_1.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return containsNumber(e[0]); throw new Error("coordinates must only contain numbers") } function geojsonType(e, r, t) { if (!r || !t) throw new Error("type and name required"); if (!e || e.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.type) } function featureOf(e, r, t) { if (!e) throw new Error("No feature passed"); if (!t) throw new Error(".featureOf() requires a name"); if (!e || "Feature" !== e.type || !e.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!e.geometry || e.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + e.geometry.type) } function collectionOf(e, r, t) { if (!e) throw new Error("No featureCollection passed"); if (!t) throw new Error(".collectionOf() requires a name"); if (!e || "FeatureCollection" !== e.type) throw new Error("Invalid input to " + t + ", FeatureCollection required"); for (var o = 0, n = e.features; o < n.length; o++) { var i = n[o]; if (!i || "Feature" !== i.type || !i.geometry) throw new Error("Invalid input to " + t + ", Feature with geometry required"); if (!i.geometry || i.geometry.type !== r) throw new Error("Invalid input to " + t + ": must be a " + r + ", given " + i.geometry.type) } } function getGeom(e) { return "Feature" === e.type ? e.geometry : e } function getType(e, r) { return "FeatureCollection" === e.type ? "FeatureCollection" : "GeometryCollection" === e.type ? "GeometryCollection" : "Feature" === e.type && null !== e.geometry ? e.geometry.type : e.type } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers_1 = require("@turf/helpers"); exports.getCoord = getCoord, exports.getCoords = getCoords, exports.containsNumber = containsNumber, exports.geojsonType = geojsonType, exports.featureOf = featureOf, exports.collectionOf = collectionOf, exports.getGeom = getGeom, exports.getType = getType;
        }, { "@turf/helpers": 18 }], 20: [function (require, module, exports) {
            "use strict"; function coordEach(e, t, r) { if (null !== e) for (var n, o, i, a, l, u, c, s, g = 0, f = 0, h = e.type, p = "FeatureCollection" === h, d = "Feature" === h, y = p ? e.features.length : 1, m = 0; m < y; m++) { c = p ? e.features[m].geometry : d ? e.geometry : e, s = !!c && "GeometryCollection" === c.type, l = s ? c.geometries.length : 1; for (var v = 0; v < l; v++) { var E = 0, P = 0; if (null !== (a = s ? c.geometries[v] : c)) { u = a.coordinates; var w = a.type; switch (g = !r || "Polygon" !== w && "MultiPolygon" !== w ? 0 : 1, w) { case null: break; case "Point": if (!1 === t(u, f, m, E, P)) return !1; f++, E++; break; case "LineString": case "MultiPoint": for (n = 0; n < u.length; n++) { if (!1 === t(u[n], f, m, E, P)) return !1; f++, "MultiPoint" === w && E++ } "LineString" === w && E++; break; case "Polygon": case "MultiLineString": for (n = 0; n < u.length; n++) { for (o = 0; o < u[n].length - g; o++) { if (!1 === t(u[n][o], f, m, E, P)) return !1; f++ } "MultiLineString" === w && E++, "Polygon" === w && P++ } "Polygon" === w && E++; break; case "MultiPolygon": for (n = 0; n < u.length; n++) { for (P = 0, o = 0; o < u[n].length; o++) { for (i = 0; i < u[n][o].length - g; i++) { if (!1 === t(u[n][o][i], f, m, E, P)) return !1; f++ } P++ } E++ } break; case "GeometryCollection": for (n = 0; n < a.geometries.length; n++)if (!1 === coordEach(a.geometries[n], t, r)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function coordReduce(e, t, r, n) { var o = r; return coordEach(e, function (e, n, i, a, l) { o = 0 === n && void 0 === r ? e : t(o, e, n, i, a, l) }, n), o } function propEach(e, t) { var r; switch (e.type) { case "FeatureCollection": for (r = 0; r < e.features.length && !1 !== t(e.features[r].properties, r); r++); break; case "Feature": t(e.properties, 0) } } function propReduce(e, t, r) { var n = r; return propEach(e, function (e, o) { n = 0 === o && void 0 === r ? e : t(n, e, o) }), n } function featureEach(e, t) { if ("Feature" === e.type) t(e, 0); else if ("FeatureCollection" === e.type) for (var r = 0; r < e.features.length && !1 !== t(e.features[r], r); r++); } function featureReduce(e, t, r) { var n = r; return featureEach(e, function (e, o) { n = 0 === o && void 0 === r ? e : t(n, e, o) }), n } function coordAll(e) { var t = []; return coordEach(e, function (e) { t.push(e) }), t } function geomEach(e, t) { var r, n, o, i, a, l, u, c, s, g, f = 0, h = "FeatureCollection" === e.type, p = "Feature" === e.type, d = h ? e.features.length : 1; for (r = 0; r < d; r++) { for (l = h ? e.features[r].geometry : p ? e.geometry : e, c = h ? e.features[r].properties : p ? e.properties : {}, s = h ? e.features[r].bbox : p ? e.bbox : void 0, g = h ? e.features[r].id : p ? e.id : void 0, u = !!l && "GeometryCollection" === l.type, a = u ? l.geometries.length : 1, o = 0; o < a; o++)if (null !== (i = u ? l.geometries[o] : l)) switch (i.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === t(i, f, c, s, g)) return !1; break; case "GeometryCollection": for (n = 0; n < i.geometries.length; n++)if (!1 === t(i.geometries[n], f, c, s, g)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === t(null, f, c, s, g)) return !1; f++ } } function geomReduce(e, t, r) { var n = r; return geomEach(e, function (e, o, i, a, l) { n = 0 === o && void 0 === r ? e : t(n, e, o, i, a, l) }), n } function flattenEach(e, t) { geomEach(e, function (e, r, n, o, i) { var a = null === e ? null : e.type; switch (a) { case null: case "Point": case "LineString": case "Polygon": if (!1 === t(helpers.feature(e, n, { bbox: o, id: i }), r, 0)) return !1; return }var l; switch (a) { case "MultiPoint": l = "Point"; break; case "MultiLineString": l = "LineString"; break; case "MultiPolygon": l = "Polygon" }for (var u = 0; u < e.coordinates.length; u++) { var c = e.coordinates[u], s = { type: l, coordinates: c }; if (!1 === t(helpers.feature(s, n), r, u)) return !1 } }) } function flattenReduce(e, t, r) { var n = r; return flattenEach(e, function (e, o, i) { n = 0 === o && 0 === i && void 0 === r ? e : t(n, e, o, i) }), n } function segmentEach(e, t) { flattenEach(e, function (e, r, n) { var o = 0; if (e.geometry) { var i = e.geometry.type; if ("Point" !== i && "MultiPoint" !== i) { var a, l = 0, u = 0, c = 0; return !1 !== coordEach(e, function (i, s, g, f, h) { if (void 0 === a || r > l || f > u || h > c) return a = i, l = r, u = f, c = h, void (o = 0); var p = helpers.lineString([a, i], e.properties); if (!1 === t(p, r, n, h, o)) return !1; o++, a = i }) && void 0 } } }) } function segmentReduce(e, t, r) { var n = r, o = !1; return segmentEach(e, function (e, i, a, l, u) { n = !1 === o && void 0 === r ? e : t(n, e, i, a, l, u), o = !0 }), n } function lineEach(e, t) { if (!e) throw new Error("geojson is required"); flattenEach(e, function (e, r, n) { if (null !== e.geometry) { var o = e.geometry.type, i = e.geometry.coordinates; switch (o) { case "LineString": if (!1 === t(e, r, n, 0, 0)) return !1; break; case "Polygon": for (var a = 0; a < i.length; a++)if (!1 === t(helpers.lineString(i[a], e.properties), r, n, a)) return !1 } } }) } function lineReduce(e, t, r) { var n = r; return lineEach(e, function (e, o, i, a) { n = 0 === o && void 0 === r ? e : t(n, e, o, i, a) }), n } function findSegment(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var r, n = t.featureIndex || 0, o = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a = t.segmentIndex || 0, l = t.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), l = l || e.features[n].properties, r = e.features[n].geometry; break; case "Feature": l = l || e.properties, r = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": r = e; break; default: throw new Error("geojson is invalid") }if (null === r) return null; var u = r.coordinates; switch (r.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), helpers.lineString([u[a], u[a + 1]], l, t); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), helpers.lineString([u[i][a], u[i][a + 1]], l, t); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), helpers.lineString([u[o][a], u[o][a + 1]], l, t); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a - 1), helpers.lineString([u[o][i][a], u[o][i][a + 1]], l, t) }throw new Error("geojson is invalid") } function findPoint(e, t) { if (t = t || {}, !helpers.isObject(t)) throw new Error("options is invalid"); var r, n = t.featureIndex || 0, o = t.multiFeatureIndex || 0, i = t.geometryIndex || 0, a = t.coordIndex || 0, l = t.properties; switch (e.type) { case "FeatureCollection": n < 0 && (n = e.features.length + n), l = l || e.features[n].properties, r = e.features[n].geometry; break; case "Feature": l = l || e.properties, r = e.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": r = e; break; default: throw new Error("geojson is invalid") }if (null === r) return null; var u = r.coordinates; switch (r.type) { case "Point": return helpers.point(u, l, t); case "MultiPoint": return o < 0 && (o = u.length + o), helpers.point(u[o], l, t); case "LineString": return a < 0 && (a = u.length + a), helpers.point(u[a], l, t); case "Polygon": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), helpers.point(u[i][a], l, t); case "MultiLineString": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), helpers.point(u[o][a], l, t); case "MultiPolygon": return o < 0 && (o = u.length + o), i < 0 && (i = u[o].length + i), a < 0 && (a = u[o][i].length - a), helpers.point(u[o][i][a], l, t) }throw new Error("geojson is invalid") } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers = require("@turf/helpers"); exports.coordEach = coordEach, exports.coordReduce = coordReduce, exports.propEach = propEach, exports.propReduce = propReduce, exports.featureEach = featureEach, exports.featureReduce = featureReduce, exports.coordAll = coordAll, exports.geomEach = geomEach, exports.geomReduce = geomReduce, exports.flattenEach = flattenEach, exports.flattenReduce = flattenReduce, exports.segmentEach = segmentEach, exports.segmentReduce = segmentReduce, exports.lineEach = lineEach, exports.lineReduce = lineReduce, exports.findSegment = findSegment, exports.findPoint = findPoint;

        }, { "@turf/helpers": 18 }], 21: [function (require, module, exports) {
            "use strict"; function rhumbDistance(t, a, e) { void 0 === e && (e = {}); var r = invariant_1.getCoord(t), h = invariant_1.getCoord(a); h[0] += h[0] - r[0] > 180 ? -360 : r[0] - h[0] > 180 ? 360 : 0; var n = calculateRhumbDistance(r, h); return helpers_1.convertLength(n, "meters", e.units) } function calculateRhumbDistance(t, a, e) { e = void 0 === e ? helpers_1.earthRadius : Number(e); var r = e, h = t[1] * Math.PI / 180, n = a[1] * Math.PI / 180, i = n - h, u = Math.abs(a[0] - t[0]) * Math.PI / 180; u > Math.PI && (u -= 2 * Math.PI); var s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(h / 2 + Math.PI / 4)), o = Math.abs(s) > 1e-11 ? i / s : Math.cos(h); return Math.sqrt(i * i + o * o * u * u) * r } Object.defineProperty(exports, "__esModule", { value: !0 }); var helpers_1 = require("@turf/helpers"), invariant_1 = require("@turf/invariant"); exports.default = rhumbDistance;

        }, { "@turf/helpers": 18, "@turf/invariant": 19 }], 22: [function (require, module, exports) {
            "use strict"; function quickselect(t, e, n, i, r) { quickselectStep(t, e, n || 0, i || t.length - 1, r || defaultCompare) } function quickselectStep(t, e, n, i, r) { for (; i > n;) { if (i - n > 600) { var o = i - n + 1, a = e - n + 1, h = Math.log(o), s = .5 * Math.exp(2 * h / 3), l = .5 * Math.sqrt(h * s * (o - s) / o) * (a - o / 2 < 0 ? -1 : 1); quickselectStep(t, e, Math.max(n, Math.floor(e - a * s / o + l)), Math.min(i, Math.floor(e + (o - a) * s / o + l)), r) } var c = t[e], u = n, f = i; for (swap(t, n, e), r(t[i], c) > 0 && swap(t, n, i); u < f;) { for (swap(t, u, f), u++, f--; r(t[u], c) < 0;)u++; for (; r(t[f], c) > 0;)f-- } 0 === r(t[n], c) ? swap(t, n, f) : (f++, swap(t, f, i)), f <= e && (n = f + 1), e <= f && (i = f - 1) } } function swap(t, e, n) { var i = t[e]; t[e] = t[n], t[n] = i } function defaultCompare(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function rbush(t, e) { if (!(this instanceof rbush)) return new rbush(t, e); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), e && this._initFormat(e), this.clear() } function findItem(t, e, n) { if (!n) return e.indexOf(t); for (var i = 0; i < e.length; i++)if (n(t, e[i])) return i; return -1 } function calcBBox(t, e) { distBBox(t, 0, t.children.length, e, t) } function distBBox(t, e, n, i, r) { r || (r = createNode(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0; for (var o, a = e; a < n; a++)o = t.children[a], extend(r, t.leaf ? i(o) : o); return r } function extend(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function compareNodeMinX(t, e) { return t.minX - e.minX } function compareNodeMinY(t, e) { return t.minY - e.minY } function bboxArea(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function bboxMargin(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function enlargedArea(t, e) { return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY)) } function intersectionArea(t, e) { var n = Math.max(t.minX, e.minX), i = Math.max(t.minY, e.minY), r = Math.min(t.maxX, e.maxX), o = Math.min(t.maxY, e.maxY); return Math.max(0, r - n) * Math.max(0, o - i) } function contains(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function intersects(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function createNode(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function multiSelect(t, e, n, i, r) { for (var o, a = [e, n]; a.length;)n = a.pop(), e = a.pop(), n - e <= i || (o = e + Math.ceil((n - e) / i / 2) * i, quickselect(t, o, e, n, r), a.push(e, o, o, n)) } function coordEach(t, e, n) { if (null !== t) { var i, r, o, a, h, s, l, c, u, f, m = 0, x = 0, d = t.type, p = "FeatureCollection" === d, b = "Feature" === d, g = p ? t.features.length : 1; for (i = 0; i < g; i++)for (u = p ? t.features[i].geometry : b ? t.geometry : t, f = !!u && "GeometryCollection" === u.type, l = f ? u.geometries.length : 1, r = 0; r < l; r++) { var B = 0; if (null !== (s = f ? u.geometries[r] : u)) { c = s.coordinates; var M = s.type; switch (m = !n || "Polygon" !== M && "MultiPolygon" !== M ? 0 : 1, M) { case null: break; case "Point": e(c, x, i, B), x++, B++; break; case "LineString": case "MultiPoint": for (o = 0; o < c.length; o++)e(c[o], x, i, B), x++, "MultiPoint" === M && B++; "LineString" === M && B++; break; case "Polygon": case "MultiLineString": for (o = 0; o < c.length; o++) { for (a = 0; a < c[o].length - m; a++)e(c[o][a], x, i, B), x++; "MultiLineString" === M && B++ } "Polygon" === M && B++; break; case "MultiPolygon": for (o = 0; o < c.length; o++) { for (a = 0; a < c[o].length; a++)for (h = 0; h < c[o][a].length - m; h++)e(c[o][a][h], x, i, B), x++; B++ } break; case "GeometryCollection": for (o = 0; o < s.geometries.length; o++)coordEach(s.geometries[o], e, n); break; default: throw new Error("Unknown Geometry Type") } } } } } function featureEach(t, e) { if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length; n++)e(t.features[n], n) } function geojsonRbush(t) { var e = rbush(t); return e.insert = function (t) { if (Array.isArray(t)) { var e = t; t = bboxPolygon(e), t.bbox = e } else t.bbox = t.bbox ? t.bbox : turfBBox(t); return rbush.prototype.insert.call(this, t) }, e.load = function (t) { var e = []; return Array.isArray(t) ? t.forEach(function (t) { var n = bboxPolygon(t); n.bbox = t, e.push(n) }) : featureEach(t, function (t) { t.bbox = t.bbox ? t.bbox : turfBBox(t), e.push(t) }), rbush.prototype.load.call(this, e) }, e.remove = function (t) { if (Array.isArray(t)) { var e = t; t = bboxPolygon(e), t.bbox = e } return rbush.prototype.remove.call(this, t) }, e.clear = function () { return rbush.prototype.clear.call(this) }, e.search = function (t) { return { type: "FeatureCollection", features: rbush.prototype.search.call(this, this.toBBox(t)) } }, e.collides = function (t) { return rbush.prototype.collides.call(this, this.toBBox(t)) }, e.all = function () { return { type: "FeatureCollection", features: rbush.prototype.all.call(this) } }, e.toJSON = function () { return rbush.prototype.toJSON.call(this) }, e.fromJSON = function (t) { return rbush.prototype.fromJSON.call(this, t) }, e.toBBox = function (t) { var e; return e = t.bbox ? t.bbox : Array.isArray(t) && 4 === t.length ? t : turfBBox(t), { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] } }, e } function bboxPolygon(t) { var e = [t[0], t[1]], n = [t[0], t[3]], i = [t[2], t[3]]; return { type: "Feature", bbox: t, properties: {}, geometry: { type: "Polygon", coordinates: [[e, [t[2], t[1]], i, n, e]] } } } function turfBBox(t) { var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return coordEach(t, function (t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) }), e } rbush.prototype = { all: function () { return this._all(this.data, []) }, search: function (t) { var e = this.data, n = [], i = this.toBBox; if (!intersects(t, e)) return n; for (var r, o, a, h, s = []; e;) { for (r = 0, o = e.children.length; r < o; r++)a = e.children[r], h = e.leaf ? i(a) : a, intersects(t, h) && (e.leaf ? n.push(a) : contains(t, h) ? this._all(a, n) : s.push(a)); e = s.pop() } return n }, collides: function (t) { var e = this.data, n = this.toBBox; if (!intersects(t, e)) return !1; for (var i, r, o, a, h = []; e;) { for (i = 0, r = e.children.length; i < r; i++)if (o = e.children[i], a = e.leaf ? n(o) : o, intersects(t, a)) { if (e.leaf || contains(t, a)) return !0; h.push(o) } e = h.pop() } return !1 }, load: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (var e = 0, n = t.length; e < n; e++)this.insert(t[e]); return this } var i = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === i.height) this._splitRoot(this.data, i); else { if (this.data.height < i.height) { var r = this.data; this.data = i, i = r } this._insert(i, this.data.height - i.height - 1, !0) } else this.data = i; return this }, insert: function (t) { return t && this._insert(t, this.data.height - 1), this }, clear: function () { return this.data = createNode([]), this }, remove: function (t, e) { if (!t) return this; for (var n, i, r, o, a = this.data, h = this.toBBox(t), s = [], l = []; a || s.length;) { if (a || (a = s.pop(), i = s[s.length - 1], n = l.pop(), o = !0), a.leaf && -1 !== (r = findItem(t, a.children, e))) return a.children.splice(r, 1), s.push(a), this._condense(s), this; o || a.leaf || !contains(a, h) ? i ? (n++, a = i.children[n], o = !1) : a = null : (s.push(a), l.push(n), n = 0, i = a, a = a.children[0]) } return this }, toBBox: function (t) { return t }, compareMinX: compareNodeMinX, compareMinY: compareNodeMinY, toJSON: function () { return this.data }, fromJSON: function (t) { return this.data = t, this }, _all: function (t, e) { for (var n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, _build: function (t, e, n, i) { var r, o = n - e + 1, a = this._maxEntries; if (o <= a) return r = createNode(t.slice(e, n + 1)), calcBBox(r, this.toBBox), r; i || (i = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, i - 1))), r = createNode([]), r.leaf = !1, r.height = i; var h, s, l, c, u = Math.ceil(o / a), f = u * Math.ceil(Math.sqrt(a)); for (multiSelect(t, e, n, f, this.compareMinX), h = e; h <= n; h += f)for (l = Math.min(h + f - 1, n), multiSelect(t, h, l, u, this.compareMinY), s = h; s <= l; s += u)c = Math.min(s + u - 1, l), r.children.push(this._build(t, s, c, i - 1)); return calcBBox(r, this.toBBox), r }, _chooseSubtree: function (t, e, n, i) { for (var r, o, a, h, s, l, c, u; ;) { if (i.push(e), e.leaf || i.length - 1 === n) break; for (c = u = 1 / 0, r = 0, o = e.children.length; r < o; r++)a = e.children[r], s = bboxArea(a), l = enlargedArea(t, a) - s, l < u ? (u = l, c = s < c ? s : c, h = a) : l === u && s < c && (c = s, h = a); e = h || e.children[0] } return e }, _insert: function (t, e, n) { var i = this.toBBox, r = n ? t : i(t), o = [], a = this._chooseSubtree(r, this.data, e, o); for (a.children.push(t), extend(a, r); e >= 0 && o[e].children.length > this._maxEntries;)this._split(o, e), e--; this._adjustParentBBoxes(r, o, e) }, _split: function (t, e) { var n = t[e], i = n.children.length, r = this._minEntries; this._chooseSplitAxis(n, r, i); var o = this._chooseSplitIndex(n, r, i), a = createNode(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, calcBBox(n, this.toBBox), calcBBox(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, _splitRoot: function (t, e) { this.data = createNode([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, calcBBox(this.data, this.toBBox) }, _chooseSplitIndex: function (t, e, n) { var i, r, o, a, h, s, l, c; for (s = l = 1 / 0, i = e; i <= n - e; i++)r = distBBox(t, 0, i, this.toBBox), o = distBBox(t, i, n, this.toBBox), a = intersectionArea(r, o), h = bboxArea(r) + bboxArea(o), a < s ? (s = a, c = i, l = h < l ? h : l) : a === s && h < l && (l = h, c = i); return c }, _chooseSplitAxis: function (t, e, n) { var i = t.leaf ? this.compareMinX : compareNodeMinX, r = t.leaf ? this.compareMinY : compareNodeMinY; this._allDistMargin(t, e, n, i) < this._allDistMargin(t, e, n, r) && t.children.sort(i) }, _allDistMargin: function (t, e, n, i) { t.children.sort(i); var r, o, a = this.toBBox, h = distBBox(t, 0, e, a), s = distBBox(t, n - e, n, a), l = bboxMargin(h) + bboxMargin(s); for (r = e; r < n - e; r++)o = t.children[r], extend(h, t.leaf ? a(o) : o), l += bboxMargin(h); for (r = n - e - 1; r >= e; r--)o = t.children[r], extend(s, t.leaf ? a(o) : o), l += bboxMargin(s); return l }, _adjustParentBBoxes: function (t, e, n) { for (var i = n; i >= 0; i--)extend(e[i], t) }, _condense: function (t) { for (var e, n = t.length - 1; n >= 0; n--)0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children, e.splice(e.indexOf(t[n]), 1)) : this.clear() : calcBBox(t[n], this.toBBox) }, _initFormat: function (t) { var e = ["return a", " - b", ";"]; this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};") } }, module.exports = geojsonRbush, module.exports.default = geojsonRbush;
        }, {}], 23: [function (require, module, exports) {
            module.exports = { lineSlice: require("@turf/line-slice"), lineSliceAlong: require("@turf/line-slice-along"), pointToLineDistance: require("@turf/point-to-line-distance"), along: require("@turf/along"), bearing: require("@turf/bearing"), helpers: require("@turf/helpers"), length: require("@turf/length"), nearestPoint: require("@turf/nearest-point"), distance: require("@turf/distance") };
        }, { "@turf/along": 1, "@turf/bearing": 2, "@turf/distance": 5, "@turf/helpers": 6, "@turf/length": 8, "@turf/line-slice": 12, "@turf/line-slice-along": 11, "@turf/nearest-point": 15, "@turf/point-to-line-distance": 16 }]
    }, {}, [23])(23)
});
